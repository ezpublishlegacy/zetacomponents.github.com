<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html 
	xmlns="http://www.w3.org/1999/xhtml"
	xml:lang="en"
	lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

	<meta name="description" content="Zeta Components - reusable set of high quality PHP components to fasten your development." />
	<meta name="keywords" content="PHP, apache, components, framework, quality" />
	<meta name="author" content="dotxp" />
	<meta name="language" content="en" />
	<meta name="date" content="Wed, 04 Aug 2010 13:07:09 +0200" />
	<meta name="robots" content="all" />

	<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" />
	<meta name="DC.title" content="Theoretical_background " />
	<meta name="DC.creator" content="dotxp" />
	<meta name="DC.date" content="Wed, 04 Aug 2010 13:07:09 +0200" />
	<meta name="DC.rights" content="Copyright" />

	<link rel="meta" href="/documentation/trunk/Workflow/theoretical_background.rdf" />
	<link rel="icon" href="/images/favicon.png" type="image/png" />

	<link rel="Stylesheet" type="text/css" href="/styles/screen.css" media="screen" />
	<link rel="Stylesheet" type="text/css" href="/styles/print.css" media="print" />


	<title>Zeta Components - high quality PHP components</title>
</head>
<body>
<div id="wcv">
	<h1>
		<a id="header-png" href="" title="Zeta Components - high quality PHP components">
			Zeta Components - high quality PHP components
		</a>
	</h1>

	<ul class="navigation">
<li >
	<a href="/news.html" title="About">About</a>
	</li>
<li >
	<a href="/community/index.html" title="Community">Community</a>
	</li>
<li class="requested">
	<a href="/documentation/overview.html" title="Documentation">Documentation</a>
	</li>
<li >
	<a href="/download/index.html" title="Download">Download</a>
	</li>
<li >
	<a href="/support.html" title="Support">Support</a>
	</li>

</ul>
<ul class="subnavigation">
<li >
	<a href="/documentation/overview.html" title="Overview">Overview</a>
	</li>
<li >
	<a href="/documentation/install.html" title="Installation">Installation</a>
	</li>

</ul>

	<div class="content">
    <ul class="tabs">
    <li >
	<a href="/documentation/trunk/Workflow/tutorial.html" title="Tutorial">Tutorial</a>
	</li>
<li >
	<a href="/documentation/trunk/Workflow/phpdoc/classtrees.html" title="API">API</a>
	</li>
<li class="requested">
	<a href="/documentation/trunk/Workflow/theoretical_background.html" title="Theoretical_background ">Theoretical_background </a>
	</li>

</ul>

		<h2>eZ Components - Workflow - Theoretical Background</h2><div class="toc"><h3>Table of Contents</h3><ul><li><p><a href="#introduction">Introduction</a></p></li><li><p><a href="#workflow-patterns">Workflow Patterns</a></p><ul><li><p><a href="#basic-control-flow-patterns">Basic Control Flow Patterns</a></p><ul><li><p><a href="#sequence">Sequence</a></p></li><li><p><a href="#parallel-split-and-split">Parallel Split (AND-Split)</a></p></li><li><p><a href="#synchronization-and-join">Synchronization (AND-Join)</a></p></li><li><p><a href="#exclusive-choice-xor-split">Exclusive Choice (XOR-Split)</a></p></li><li><p><a href="#simple-merge-xor-join">Simple Merge (XOR-Join)</a></p></li></ul></li><li><p><a href="#advanced-branching-and-synchronization">Advanced Branching and Synchronization</a></p><ul><li><p><a href="#multi-choice-or-split">Multi-Choice (OR-Split)</a></p></li><li><p><a href="#synchronizing-merge">Synchronizing Merge</a></p></li><li><p><a href="#discriminator">Discriminator</a></p></li></ul></li><li><p><a href="#structural-patterns">Structural Patterns</a></p><ul><li><p><a href="#arbitrary-cycles">Arbitrary Cycles</a></p></li><li><p><a href="#implicit-termination">Implicit Termination</a></p></li></ul></li><li><p><a href="#cancellation-patterns">Cancellation Patterns</a></p><ul><li><p><a href="#cancel-case">Cancel Case</a></p></li></ul></li></ul></li><li><p><a href="#workflow-model">Workflow Model</a></p><ul><li><p><a href="#activities-and-transitions">Activities and Transitions</a></p><ul><li><p><a href="#graph-traversal-and-execution-strategy">Graph Traversal and Execution Strategy</a></p></li></ul></li><li><p><a href="#state-and-workflow-variables">State and Workflow Variables</a></p><ul><li><p><a href="#wait-states">Wait States</a></p></li></ul></li><li><p><a href="#control-flow">Control Flow</a></p></li><li><p><a href="#action-nodes-and-service-objects">Action Nodes and Service Objects</a></p></li><li><p><a href="#sub-workflows">Sub-Workflows</a></p></li></ul></li><li><p><a href="#design-and-implementation">Design and Implementation</a></p><ul><li><p><a href="#architecture">Architecture</a></p></li><li><p><a href="#workflow-virtual-machine">Workflow Virtual Machine</a></p></li><li><p><a href="#graph-oriented-programming">Graph-Oriented Programming</a></p></li></ul></li></ul></div><a name="introduction"></a><a name="id19"></a><h3>Introduction</h3><p>This document contains theoretical background information on the Workflow engine. It is an excerpt from Sebastian Bergmann's <a href="http://sebastian-bergmann.de/publications/bergmann-WorkflowEngine-DiplomaThesis.pdf">diploma thesis</a>.</p><a name="workflow-patterns"></a><a name="id20"></a><h3>Workflow Patterns</h3><p>In Chapter 3 of his <a href="http://is.tm.tue.nl/research/patterns/download/phd_bartek.pdf">PhD thesis</a>, Kiepuszewski lists <em>requirements for
workflow languages through workflow patterns</em>.</p><p>Much like the <a href="http://en.wikipedia.org/wiki/Design_Patterns">software design patterns</a>, these workflow patterns describe recurring solutions to common problems. They are relevant to both the implementor and the user of a workflow management system. The former uses the workflow patterns as a common vocabulary for workflow description language constructs and to define the semantics of a workflow model whereas the latter uses them as a guide while formulating his workflow in the workflow system's description language. The workflow patterns also faciliate the comparison with other workflow systems with regard to expressiveness and power.</p><p>In Chapter 4 of his <a href="http://is.tm.tue.nl/research/patterns/download/phd_bartek.pdf">PhD thesis</a>, Kiepuszewski maps the workflow patterns that he identified to Petri nets to provide a formal foundation for this more pragmatic approach to defining workflow semantics.</p><p>In this section we discuss the subset of the workflow patterns identified by Kiepuszewski that is directly supported by the Workflow component.</p><a name="basic-control-flow-patterns"></a><a name="id21"></a><h4>Basic Control Flow Patterns</h4><p>The workflow patterns for basic control flow <em>capture elementary aspects of
process control</em> and <em>closely match the definitions of elementary
control flow concepts</em> provided by the Workflow Management Coalition in [<a href="http://www.wfmc.org/standards/docs/tc003v11.pdf">WfMC95</a>, <a href="http://www.wfmc.org/standards/docs/TC-1011_term_glossary_v3.pdf">WfMC99</a>].</p><a name="sequence"></a><a name="id22"></a><h5>Sequence</h5><p>The Sequence workflow pattern represents linear execution of workflow steps: one action of a workflow is activated unconditionally (for example <em>B</em> the figure below) after another (for example <em>A</em> in the figure below) finished executing.</p><div class="&#10;&#9;&#9;&#9;&#9;&#9;image &#10;&#9;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;center&#10;&#9;&#9;&#9;&#9;&#9;&#9; "><img alt="" title="" src="img/sequence.png"/><span class="image_title"/></div>The Sequence workflow pattern<p><strong>Use Case Example:</strong> After an order is placed, the credit card specified by the customer is charged.</p><a name="parallel-split-and-split"></a><a name="id23"></a><h5>Parallel Split (AND-Split)</h5><p>The Parallel Split workflow pattern divides one thread of execution (for example the one that activates <em>A</em> in the figure below) unconditionally into multiple parallel threads of execution (for example the ones that start in <em>B</em>, <em>C</em>, and <em>D</em> in the figure below).</p><div class="&#10;&#9;&#9;&#9;&#9;&#9;image &#10;&#9;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;center&#10;&#9;&#9;&#9;&#9;&#9;&#9; "><img alt="" title="" src="img/parallel_split.png"/><span class="image_title"/></div>The Parallel Split workflow pattern<p><strong>Use Case Example:</strong> After the credit card specified by the customer has been successfully charged, the activities of sending a confirmation email and starting the shipping process can be executed in parallel.</p><a name="synchronization-and-join"></a><a name="id24"></a><h5>Synchronization (AND-Join)</h5><p>The Synchronization workflow pattern synchronizes multiple parallel threads of execution (for example the ones that end in <em>B</em>, <em>C</em>, and <em>D</em> in the figure below) into a single thread of execution (for example the one that starts in <em>E</em> in the figure below).</p><p>Workflow execution continues once all threads of execution that are to be synchronized have finished executing (exactly once).</p><div class="&#10;&#9;&#9;&#9;&#9;&#9;image &#10;&#9;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;center&#10;&#9;&#9;&#9;&#9;&#9;&#9; "><img alt="" title="" src="img/synchronization.png"/><span class="image_title"/></div>The Synchronization workflow pattern<p><strong>Use Case Example:</strong> After the confirmation email has been sent and the shipping process has been completed, the order can be archived.</p><p>The workflow patterns that have been discussed so far handle the <em>unconditional routing</em> of control flow. We will now take a look at the workflow patterns for <em>conditional routing</em>.</p><a name="exclusive-choice-xor-split"></a><a name="id25"></a><h5>Exclusive Choice (XOR-Split)</h5><p>The Exclusive Choice workflow pattern defines multiple possible paths (for example the ones that start in <em>B</em>, <em>C</em>, and <em>D</em> in the figure below) for the workflow of which exactly one is chosen (for example the one that starts in <em>C</em> in the figure below).</p><div class="&#10;&#9;&#9;&#9;&#9;&#9;image &#10;&#9;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;center&#10;&#9;&#9;&#9;&#9;&#9;&#9; "><img alt="" title="" src="img/exclusive_choice.png"/><span class="image_title"/></div>The Exclusive Choice workflow pattern<p><strong>Use Case Example:</strong> After an order has been received, the payment can be performed by either credit card or bank transfer.</p><a name="simple-merge-xor-join"></a><a name="id26"></a><h5>Simple Merge (XOR-Join)</h5><p>The Simple Merge workflow pattern is to be used to merge the possible paths that are defined by a preceding Exclusive Choice. It is assumed that of these possible paths exactly one is taken (for example <em>C</em> in the figure below) and no synchronization takes place.</p><div class="&#10;&#9;&#9;&#9;&#9;&#9;image &#10;&#9;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;center&#10;&#9;&#9;&#9;&#9;&#9;&#9; "><img alt="" title="" src="img/simple_merge.png"/><span class="image_title"/></div>The Simple Merge workflow pattern<p><strong>Use Case Example:</strong> After the payment has been performed by either credit card or bank transfer, the order can be processed further.</p><a name="advanced-branching-and-synchronization"></a><a name="id27"></a><h4>Advanced Branching and Synchronization</h4><p>The workflow patterns for advanced branching and synchronization <em>do not have
straightforward support in most [of the] workflow engines [that
Kiepuszewski evaluated]</em>. <em>Nevertheless, they are quite common in real-life
business scenarios</em>.</p><a name="multi-choice-or-split"></a><a name="id28"></a><h5>Multi-Choice (OR-Split)</h5><p>The Multi-Choice workflow pattern defines multiple possible paths (for example the ones that start in <em>B</em>, <em>C</em>, and <em>D</em> in the figure below) for the workflow of which one or more are chosen (for example the ones that start in <em>B</em> and <em>D</em> in the figure below). It is a generalization of the Parallel Split and Exclusive Choice workflow patterns.</p><div class="&#10;&#9;&#9;&#9;&#9;&#9;image &#10;&#9;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;center&#10;&#9;&#9;&#9;&#9;&#9;&#9; "><img alt="" title="" src="img/multi_choice.png"/><span class="image_title"/></div>The Multi-Choice workflow pattern<a name="synchronizing-merge"></a><a name="id29"></a><h5>Synchronizing Merge</h5><p>The Synchronizing Merge workflow pattern is to be used to synchronize multiple parallel threads of execution that are activated by a preceding Multi-Choice (for example the ones that end in <em>B</em> and <em>D</em> in the figure below).</p><div class="&#10;&#9;&#9;&#9;&#9;&#9;image &#10;&#9;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;center&#10;&#9;&#9;&#9;&#9;&#9;&#9; "><img alt="" title="" src="img/synchronizing_merge.png"/><span class="image_title"/></div>The Synchronizing Merge workflow pattern<a name="discriminator"></a><a name="id30"></a><h5>Discriminator</h5><p>The Discriminator workflow pattern can be applied when the assumption we made for the Simple Merge workflow pattern does not hold. It can deal with merge situations where multiple incoming branches may run in parallel.</p><p>It activates its outgoing node after being activated by the first incoming branch and then waits for all remaining branches to complete before it resets itself. After the reset the Discriminator can be triggered again.</p><p><strong>Use Case Example:</strong> To improve response time, an action is delegated to several distributed servers. The first response proceeds the flow, the other responses are ignored.</p><a name="structural-patterns"></a><a name="id31"></a><h4>Structural Patterns</h4><p>The structural workflow patterns deal with restrictions that different workflow models can impose.</p><a name="arbitrary-cycles"></a><a name="id32"></a><h5>Arbitrary Cycles</h5><p>A common restriction workflow models impose is that arbitrary cycles, ie. one or more activities are done repeatedly, are not supported. As an alternative, special loop constructs that mark the start and end point of a structured cycle are offered.</p><a name="implicit-termination"></a><a name="id33"></a><h5>Implicit Termination</h5><p>The execution of the workflow is (successfully) terminated when there are no activated activities left and no other activity can be activated. This implicit termination of workflow execution can be used in addition to explicit end activities.</p><a name="cancellation-patterns"></a><a name="id34"></a><h4>Cancellation Patterns</h4><a name="cancel-case"></a><a name="id35"></a><h5>Cancel Case</h5><p>The execution of a workflow instance is cancelled.</p><p><strong>Use Case Example:</strong> An order is cancelled.</p><a name="workflow-model"></a><a name="id36"></a><h3>Workflow Model</h3><a name="activities-and-transitions"></a><a name="id37"></a><h4>Activities and Transitions</h4><p>The workflow model is activity-based. The activities that are to be completed throughout the workflow and the transitions between them are mapped to the nodes and edges of a directed graph. This choice was made to faciliate the application of the Graph-Oriented Programming paradigm for the implementation of the Workflow component. Using a directed graph as the foundation for the workflow model makes it possible to define the syntax of the workflow description language using the formalism of graph grammars.</p><a name="graph-traversal-and-execution-strategy"></a><a name="id38"></a><h5>Graph Traversal and Execution Strategy</h5><p>The execution of a workflow starts with the graph's only <em>Start</em> node. A graph may have one or more <em>End</em> nodes that explicitly terminate the workflow execution.</p><p>After a node has finished executing, it can activate one or more of its possible outgoing nodes. Activation adds a node to a set of nodes that are waiting for execution. During each execution step, a node from this set is executed. When the execution of a node has been completed, the node is removed from the set.</p><p>The workflow execution is implicitly terminated when no nodes are activated and no more nodes can be activated (see the <em>Implicit Termination</em> workflow pattern that was discussed above).</p><a name="state-and-workflow-variables"></a><a name="id39"></a><h4>State and Workflow Variables</h4><p>The workflow model supports state through the concept of workflow variables. Such a variable can either be requested as user input (from an <em>Input</em> node) or be set and manipulated through the <em>VariableSet</em>, <em>VariableAdd</em>, <em>VariableSub</em>, <em>VariableMul</em>, <em>VariableDiv</em>, <em>VariableIncrement</em>, and <em>VariableDecrement</em> nodes.</p><p>While a <em>VariableSet</em> node may set the value of a workflow variable to any type that is supported by the underlying programming language, the other variable manipulation nodes only operate on numbers.</p><p>Variables are bound to the scope of the thread in which they were defined. This allows parallel threads of execution to use variables of the same name without side effects.</p><a name="wait-states"></a><a name="id40"></a><h5>Wait States</h5><p>When the execution of a workflow reaches an <em>Input</em> node (see above), the execution is suspended until such time when the user input has been provided and the execution can be resumed.</p><a name="control-flow"></a><a name="id41"></a><h4>Control Flow</h4><p>The control flow semantics of the workflow model draws upon the workflow patterns that were discussed above. The <em>Sequence</em>, <em>Parallel Split</em>, <em>Synchronization</em>, <em>Exclusive Choice</em>, <em>Simple Merge</em>, <em>Multi-Choice</em>, <em>Synchronizing Merge</em>, <em>Discriminator</em>, and <em>Cancel Case</em> workflow patterns are all directly supported by the workflow model.</p><p><em>Exclusive Choice</em> and <em>Multi-Choice</em> nodes have branching conditions attached to them that operate on workflow variables to make their control flow decisions. A special node, named <em>Loop</em>, to conveniently express loops is also available.</p><a name="action-nodes-and-service-objects"></a><a name="id42"></a><h4>Action Nodes and Service Objects</h4><p>So far we have only discussed nodes that control the flow and that can manipulate workflow variables. We are still missing a type of nodes that actually performs an activity. This is where the <em>Action</em> node comes into play.</p><p>When the execution of a workflow reaches an <em>Action</em> node, the business logic of the attached <em>Service Object</em> is executed. Service Objects "live" in the domain of the application into which the workflow engine is embedded. They have read and write access to the workflow variables to interact with the rest of the workflow.</p><a name="sub-workflows"></a><a name="id43"></a><h4>Sub-Workflows</h4><p>The workflow model supports sub-workflows to break down a complex workflow into parts that are easier to conceive, understand, maintain, and which can be reused.</p><p>A sub-workflow is started when the respective <em>Sub-Workflow</em> node is reached during workflow execution. The execution of the parent workflow is suspended while the sub-workflow is executing. It is resumed once the execution of the sub-workflow has ended.</p><a name="design-and-implementation"></a><a name="id44"></a><h3>Design and Implementation</h3><p>This section discusses the design and implementation of the Workflow component.</p><a name="architecture"></a><a name="id45"></a><h4>Architecture</h4><p>The Workflow engine has been designed and implemented as four loosely coupled components. The <strong>Workflow</strong> component provides an object-oriented framework to define workflows and an execution engine to execute them. The <strong>WorkflowDatabaseTiein</strong> and <strong>WorkflowEventLogTiein</strong> components tie the <strong>Database</strong> and <strong>EventLog</strong> components into the main Workflow component for persistence and monitoring, respectively. The <strong>WorkflowSignalSlotTiein</strong> component leverages the <strong>SignalSlot</strong> component for the <strong>Workflow</strong> component's plugin system.</p><p>A workflow can be defined programmatically by creating and connecting objects that represent control flow constructs. The classes for these objects are provided by the <em>Workflow Definition API</em>. This API also provides the functionality to save workflow definitions (ie. object graphs) to and load workflow definitions from a data storage. Two data storage backends have been implemented, one for relational database systems and another for XML files. Through the <em>Workflow Execution API</em> the execution of a workflow definition can be started, resumed, and cancelled. The figure below shows the conceptual architecture for the workflow engine.</p><div class="&#10;&#9;&#9;&#9;&#9;&#9;image &#10;&#9;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;center&#10;&#9;&#9;&#9;&#9;&#9;&#9; "><img alt="" title="" src="img/architecture.png"/><span class="image_title"/></div>Workflow component architecture<p>The idea that a workflow system should be comprised of loosely coupled components is discussed, for instance, in [<a href="http://historical.ncstrl.org/tr/pdf/uiuc_cs/UIUCDCS-R-2000-2186.pdf">DAM01</a>, <a href="http://citeseer.ist.psu.edu/georgakopoulos95overview.html">DG95</a>, <a href="http://citeseer.ist.psu.edu/muth99integrating.html">PM99</a>]. Manolescu states that <em>an object-oriented workflow architecture must provide
abstractions that enable software developers to define and enact how the work
flows through the system</em> [<a href="http://historical.ncstrl.org/tr/pdf/uiuc_cs/UIUCDCS-R-2000-2186.pdf">DAM01</a>].</p><p>The component-based workflow architecture Micro-Workflow <em>encapsulates
workflow features in separate components</em>. This architecture follows the <em>Microkernel</em> pattern which <em>applies to software systems that must be able to
adapt to changing system requirements. It separates a minimal functional core
from extended functionality and customer-specific parts. The microkernel also
serves as a socket for plugging in these extensions and coordinating their
collaboration</em> [<a href="http://en.wikipedia.org/wiki/Special:BookSources/0471958697">FB96</a>].</p><a name="workflow-virtual-machine"></a><a name="id46"></a><h4>Workflow Virtual Machine</h4><p>This section proposes a so-called <em>workflow virtual machine</em> as the executing component of a component-based workflow architecture.</p><p>Given the fact that <em>standardization efforts, e.g. XPDL</em> [<a href="http://www.wfmc.org/standards/docs/TC-1025_xpdl_2_2005-09-07_xpdl_2.pdf">WfMC05</a>] <em>proposed by
the WfMC, have essentially failed to gain universal acceptance</em> [<a href="http://www.yawlfoundation.org/documents/yawls.pdf">WA04</a>], the <em>problem of developing a [workflow system] that supports
changes in the [workflow description language]</em> needs to be addressed.</p><p>Fernandes et. al. propose to <em>split the [workflow system] into two layers: (1) a
layer implementing a</em> Workflow Virtual Machine, <em>which is responsible for most
of the [workflow system] activities; and (2) a layer where the different
[workflow description languages] are handled, which is responsible for making
the mapping between each [workflow description language] and the Workflow
Virtual Machine</em> [<a href="http://www.esw.inesc.pt/~ars/ps/sofsem2004.pdf">SF04</a>].</p><p>A workflow virtual machine isolates the executing part of a workflow management system, the <em>backend</em>, from the parts that users interact with, the <em>frontend</em>. This isolation allows for the definition of a <em>backend language</em> to describe exactly the workflows that are supported by the executer and its underlying workflow model. This backend language is not the workflow description language users use to define their workflows. They use <em>frontend languages</em> that can be mapped to the system's backend language.</p><a name="graph-oriented-programming"></a><a name="id47"></a><h4>Graph-Oriented Programming</h4><p>The manual of JBoss jBPM [<a href="http://docs.jboss.com/jbpm/v3/userguide/graphorientedprogramming.html">JBOSS</a>], a platform for multiple process languages supporting workflow, business process management, and process orchestration, introduces <em>Graph-Oriented Programming [as a] new implementation technique that
serves as a basis for all graph-based process languages</em>.</p><p>Graph-Oriented Programming implements the <em>graphical representation</em> and the <em>wait states</em> of a process language in an object-oriented programming language. The former can be achieved by providing a framework of node classes. Objects of these classes represent the nodes in the process graph, relations between these objects represent the edges. Such an object graph can then be traversed for execution. These executions need to be persistable, for instance in a relational database, to support the wait states.</p><p>The aforementioned node classes implement the <a href="http://en.wikipedia.org/wiki/Command_pattern">Command design pattern</a> and encapsulate an action and its parameters.</p><p>The executing part of the workflow engine is implemented in an Execution class. An object of this class represents a workflow in execution. The execution object has a reference to the current node. When the execution of a workflow is started, a new execution object is created and the current node is set to the workflow's start node. The execute() method that is to be provided by the node classes is not only responsible for executing the node's action, but also for propagating the execution: <em>a node can pass the execution that arrived in the node [to] one
of its leaving transitions to the next node</em>.</p><p>Like Fowler in [<a href="http://martinfowler.com/articles/languageWorkbench.html">MF05</a>], the authors of the JBoss jBPM manual acknowledge the fact that <em>current software development relies more and more on domain specific
languages</em>. They see Graph-Oriented Programming as a means to implement domain specific languages <em>that describe how graphs can be defined and executed</em> on top of an object-oriented programming language.</p><p>In this context, a process language (such as a workflow description language) is <em>nothing more than a set of Node implementations</em>. The semantics of each node are defined by the implementation of the execute() method in the respective node class. This language can be used as the backend language of a Workflow Virtual Machine (see above). In this lanugage, the workflow is represented as a graph of command objects. The workflow patterns (see above) make up the requirements for and can be mapped to the respective classes.</p><p>One of the advantages of using a domain specific language that Fowler gives in [<a href="http://martinfowler.com/articles/languageWorkbench.html">MF05</a>] regards the <em>involvement of lay programmers: domain experts who are not
professional programmers but program in domain specific languages as part of the
development effort</em>. In essence this means that a software system that provides a domain specific language can be customized and extended without knowledge of the underlying programming language that was used to implement it.</p>

	</div>

	<div class="footer">
	
</div>
</div>
</body>
</html>
