<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html 
	xmlns="http://www.w3.org/1999/xhtml"
	xml:lang="en"
	lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

	<meta name="description" content="Apache Zeta Components - reusable set of high quality PHP components to fasten your development." />
	<meta name="keywords" content="PHP, apache, components, framework, quality" />
	<meta name="author" content="jerome" />
	<meta name="language" content="en" />
	<meta name="date" content="Sun, 10 Jul 2011 11:10:40 +0200" />
	<meta name="robots" content="all" />

	<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" />
	<meta name="DC.title" content="Tutorial" />
	<meta name="DC.creator" content="jerome" />
	<meta name="DC.date" content="Sun, 10 Jul 2011 11:10:40 +0200" />
	<meta name="DC.rights" content="Copyright" />

	<link rel="meta" href="/zetacomponents/documentation/trunk/Template/tutorial.rdf" />
	<link rel="icon" href="/zetacomponents/images/favicon.png" type="image/png" />

	<link rel="Stylesheet" type="text/css" href="/zetacomponents/styles/screen.css" media="screen" />
	<link rel="Stylesheet" type="text/css" href="/zetacomponents/styles/print.css" media="print" />


	<title>Apache Zeta Components - high quality PHP components</title>
</head>
<body>
<div id="wcv">
	<h1>
		<a id="header-png" href="/zetacomponents" title="Apache Zeta Components - high quality PHP components">
			Apache Zeta Components - high quality PHP components
		</a>
	</h1>

	<ul class="navigation">
<li >
	<a href="/zetacomponents/news.html" title="About">About</a>
	</li>
<li >
	<a href="/zetacomponents/community/index.html" title="Community">Community</a>
	</li>
<li class="requested">
	<a href="/zetacomponents/documentation/overview.html" title="Documentation">Documentation</a>
	</li>
<li >
	<a href="/zetacomponents/download/index.html" title="Download">Download</a>
	</li>
<li >
	<a href="/zetacomponents/support.html" title="Support">Support</a>
	</li>

</ul>
<ul class="subnavigation">
<li >
	<a href="/zetacomponents/documentation/overview.html" title="Overview">Overview</a>
	</li>
<li >
	<a href="/zetacomponents/documentation/install.html" title="Installation">Installation</a>
	</li>

</ul>

	<div class="content">
    <ul class="tabs">
    <li class="requested">
	<a href="/zetacomponents/documentation/trunk/Template/tutorial.html" title="Tutorial">Tutorial</a>
	</li>
<li >
	<a href="/zetacomponents/documentation/trunk/Template/phpdoc/classtrees.html" title="API">API</a>
	</li>
<li >
	<a href="/zetacomponents/documentation/trunk/Template/functions.html" title="Functions ">Functions </a>
	</li>
<li >
	<a href="/zetacomponents/documentation/trunk/Template/EBNF.html" title="EBNF ">EBNF </a>
	</li>

</ul>

		<h2>eZ components - Template component</h2><div class="toc"><h3>Table of Contents</h3><ul><li><p><a href="#introduction">Introduction</a></p></li><li><p><a href="#class-overview">Class overview</a></p></li><li><p><a href="#template-component">Template component</a></p><ul><li><p><a href="#getting-started">Getting started</a></p></li><li><p><a href="#configuring-the-template-engine">Configuring the Template engine</a></p></li><li><p><a href="#lazy-initialization">Lazy initialization</a></p></li><li><p><a href="#send-and-receive-template-variables">Send and receive template variables</a></p></li><li><p><a href="#template-locations">Template locations</a></p></li></ul></li><li><p><a href="#template-syntax">Template syntax</a></p><ul><li><p><a href="#basic-syntax">Basic syntax</a></p><ul><li><p><a href="#escape-characters">Escape characters</a></p></li><li><p><a href="#literal-tags">Literal tags</a></p></li></ul></li><li><p><a href="#comments">Comments</a></p><ul><li><p><a href="#code-comments">Code comments</a></p></li><li><p><a href="#multi-line-in-line-comment">Multi-line in-line comment</a></p></li><li><p><a href="#single-line-in-line-comment">Single-line in-line comment</a></p></li></ul></li><li><p><a href="#primitive-types">Primitive types</a></p><ul><li><p><a href="#boolean">Boolean</a></p></li><li><p><a href="#integer">Integer</a></p></li><li><p><a href="#float">Float</a></p></li><li><p><a href="#string">String</a></p></li><li><p><a href="#array">Array</a></p></li><li><p><a href="#object">Object</a></p></li></ul></li><li><p><a href="#variables">Variables</a></p><ul><li><p><a href="#local-variable-declaration-var">Local variable declaration (var)</a></p></li><li><p><a href="#external-variable-declaration-use">External variable declaration (use)</a></p></li><li><p><a href="#cycles">Cycles</a></p></li><li><p><a href="#scopes">Scopes</a></p></li><li><p><a href="#returning-variables">Returning variables</a></p></li><li><p><a href="#capturing-content-into-variables">Capturing content into variables</a></p></li></ul></li><li><p><a href="#expressions">Expressions</a></p><ul><li><p><a href="#arithmetic-operators">Arithmetic operators</a></p></li><li><p><a href="#comparison-operators">Comparison operators</a></p></li><li><p><a href="#logical-operators">Logical operators</a></p></li></ul></li><li><p><a href="#assignments">Assignments</a></p></li><li><p><a href="#functions">Functions</a></p></li><li><p><a href="#contexts">Contexts</a></p><ul><li><p><a href="#xhtml-context">XHTML Context</a></p><ul><li><p><a href="#additional-required-escaping">Additional required escaping</a></p></li></ul></li><li><p><a href="#no-context">No Context</a></p></li></ul></li><li><p><a href="#control-structures">Control structures</a></p><ul><li><p><a href="#increment">Increment</a></p></li><li><p><a href="#decrement">Decrement</a></p></li><li><p><a href="#reset">Reset</a></p></li><li><p><a href="#if-else-elseif">If, else, elseif</a></p></li><li><p><a href="#switch-case-default">Switch, Case, Default</a></p></li><li><p><a href="#foreach">Foreach</a></p></li><li><p><a href="#while">While</a></p></li><li><p><a href="#delimiter">Delimiter</a></p></li><li><p><a href="#continue">Continue</a></p></li><li><p><a href="#skip">Skip</a></p></li><li><p><a href="#break">Break</a></p></li><li><p><a href="#include">Include</a></p></li><li><p><a href="#raw">Raw</a></p></li></ul></li><li><p><a href="#translation-constructs">Translation Constructs</a></p><ul><li><p><a href="#tr-context">tr_context</a></p></li><li><p><a href="#tr">tr</a></p></li></ul></li></ul></li><li><p><a href="#extensions">Extensions</a></p><ul><li><p><a href="#custom-blocks">Custom blocks</a></p><ul><li><p><a href="#custom-blocks-in-the-template-language">Custom blocks in the Template language</a></p></li><li><p><a href="#adding-a-custom-block">Adding a custom block</a></p></li><li><p><a href="#custom-block-definition">Custom block definition</a></p></li><li><p><a href="#implementing-the-custom-block">Implementing the custom block</a></p></li><li><p><a href="#example">Example</a></p></li></ul></li><li><p><a href="#custom-functions">Custom functions</a></p><ul><li><p><a href="#custom-functions-in-the-template-language">Custom functions in the Template language</a></p></li><li><p><a href="#adding-a-new-custom-function">Adding a new custom function</a></p></li><li><p><a href="#named-parameters">Named parameters</a></p></li><li><p><a href="#sending-template-objects">Sending template objects</a></p></li></ul></li></ul></li><li><p><a href="#caching">Caching</a></p><ul><li><p><a href="#configuration">Configuration</a></p></li><li><p><a href="#cache-tags">Cache tags</a></p></li><li><p><a href="#cache-renewal">Cache renewal</a></p><ul><li><p><a href="#cache-keys">Cache keys</a></p></li><li><p><a href="#time-to-live">Time-to-live</a></p></li></ul></li><li><p><a href="#cache-manager">Cache manager</a></p><ul><li><p><a href="#the-cache-manager-interface">The cache manager interface</a></p></li><li><p><a href="#database-storage">Database storage</a></p></li><li><p><a href="#database-fetch">Database fetch</a></p></li><li><p><a href="#loose-coupling">Loose coupling</a></p></li><li><p><a href="#including-templates">Including templates</a></p></li></ul></li></ul></li><li><p><a href="#translations">Translations</a></p></li><li><p><a href="#more-information">More information</a></p></li></ul></div><a name="introduction"></a><a name="id3"></a><h3>Introduction</h3><p>The template component provides a manageable way to separate application logic from presentation data. The application logic is the PHP code of your application, including the call to the Template component. Presentation data are the template files.</p><p>The separation of application logic and presentation data is easier to maintain and allows different people to work on separate parts. Another advantage is that the Template language is more suitable for non programmers and web designers. The language is designed to be easier to use and contains more expressive constructs for repetitive tasks in the presentation data.</p><a name="class-overview"></a><a name="id4"></a><h3>Class overview</h3><p>The following list sums up the most important API classes:</p><dl><dt>ezcTemplate</dt><dd>This class provides the main API for processing templates. This class compiles the template to PHP code, executes it, and returns the result.</dd><dt>ezcTemplateConfiguration</dt><dd>This class configures the Template engine. Settings like: where to find the source templates, where to store the compiled templates, the type of context to use, are stored in this class.</dd><dt>ezcTemplateVariableCollection</dt><dd>The variables that should be send to the template or retrieved from the template are stored in the object from this class.</dd></dl><p>More information about these classes can be found in the documentation of the class itself.</p><a name="template-component"></a><a name="id5"></a><h3>Template component</h3><p>This section describes how to use the template component in your PHP application. How to write the templates itself is described in the next section.</p><a name="getting-started"></a><a name="id6"></a><h4>Getting started</h4><p>The simplest example we can come up with is writing "Hello world" to your standard output. Basically it consists of two steps:</p><p>The first step is to create a text file "hello_world.ezt" that contains only one line:</p><code class="block">Hello world</code><p>and store it in the directory where your application sources reside.</p><p>The next step is to copy the following PHP script, and check if the application works.</p><ol class="code">
<li><span style="color: #000000">&lt;?php</span></li>
<li><span style="color: #0000FF">require_once&nbsp;</span><span style="color: #335533">'Base/src/base.php'</span><span style="color: #0000FF">;</span></li>
<li></li>
<li><span style="color: #007700">//&nbsp;Autoload&nbsp;the&nbsp;ezcomponent&nbsp;classes.</span></li>
<li><span style="color: #0000FF">function&nbsp;</span><span style="color: #000000">__autoload</span><span style="color: #0000FF">(&nbsp;</span><span style="color: #000000">$className&nbsp;</span><span style="color: #0000FF">)</span></li>
<li><span style="color: #0000FF">{</span></li>
<li><span style="color: #0000FF">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #000000"><a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcBase.html#autoload'>ezcBase::autoload</a></span><span style="color: #0000FF">(&nbsp;</span><span style="color: #000000">$className&nbsp;</span><span style="color: #0000FF">);</span></li>
<li><span style="color: #0000FF">}</span></li>
<li></li>
<li><span style="color: #007700">//&nbsp;Use&nbsp;the&nbsp;default&nbsp;configuration.&nbsp;</span></li>
<li><span style="color: #000000">$t&nbsp;</span><span style="color: #0000FF">=&nbsp;new&nbsp;</span><span style="color: #000000"><a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplate.html'>ezcTemplate</a></span><span style="color: #0000FF">();</span></li>
<li></li>
<li><span style="color: #007700">//&nbsp;Compiles&nbsp;the&nbsp;template&nbsp;and&nbsp;returns&nbsp;the&nbsp;result.</span></li>
<li><span style="color: #007700">//&nbsp;It&nbsp;searches&nbsp;for&nbsp;the&nbsp;hello_world&nbsp;template&nbsp;in&nbsp;the&nbsp;current&nbsp;directory.</span></li>
<li><span style="color: #0000FF">echo&nbsp;</span><span style="color: #000000">$t</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">process</span><span style="color: #0000FF">(&nbsp;</span><span style="color: #335533">"hello_world.ezt"&nbsp;</span><span style="color: #0000FF">);</span></li>
<li><span style="color: #000000">?&gt;</span></li>

</ol><p>If you run your application, it should print "Hello world". Otherwise check that:</p><ul><li><p>The base class can be found. Check your 'include_path' in the PHP.ini settings, and see if the components are included.</p></li><li><p>The template "hello_world.ezt" can be found. Write the absolute path to your hello_world template in the 'process' method.</p></li><li><p>The Template engine can write to the current directory. By default it tries to create the directory compiled_templates with the permissions of the running PHP process. The next section explains how another output directory can be specified.</p></li></ul><a name="configuring-the-template-engine"></a><a name="id7"></a><h4>Configuring the Template engine</h4><p>Templates are not always stored in your local directory and neither do you want to store the compiled templates among your source files. Therefore we have to change the configuration:</p><ol class="code">
<li><span style="color: #000000">&lt;?php</span></li>
<li></li>
<li><span style="color: #007700">//&nbsp;Autoload.</span></li>
<li><span style="color: #0000FF">require_once&nbsp;</span><span style="color: #335533">'tutorial_autoload.php'</span><span style="color: #0000FF">;</span></li>
<li></li>
<li><span style="color: #000000">$config&nbsp;</span><span style="color: #0000FF">=&nbsp;</span><span style="color: #000000"><a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateConfiguration.html#getInstance'>ezcTemplateConfiguration::getInstance</a></span><span style="color: #0000FF">();</span></li>
<li></li>
<li><span style="color: #000000">$config</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">templatePath&nbsp;</span><span style="color: #0000FF">=&nbsp;</span><span style="color: #335533">"/usr/share/templates"</span><span style="color: #0000FF">;</span></li>
<li><span style="color: #000000">$config</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">compilePath&nbsp;</span><span style="color: #0000FF">=&nbsp;</span><span style="color: #335533">"/tmp/compiled_templates"</span><span style="color: #0000FF">;</span></li>
<li><span style="color: #000000">$config</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">context&nbsp;</span><span style="color: #0000FF">=&nbsp;new&nbsp;</span><span style="color: #000000"><a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateXhtmlContext.html'>ezcTemplateXhtmlContext</a></span><span style="color: #0000FF">();&nbsp;&nbsp;</span><span style="color: #007700">//&nbsp;Is&nbsp;already&nbsp;the&nbsp;default,&nbsp;though.</span></li>
<li></li>
<li></li>
<li><span style="color: #000000">$t&nbsp;</span><span style="color: #0000FF">=&nbsp;new&nbsp;</span><span style="color: #000000"><a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplate.html'>ezcTemplate</a></span><span style="color: #0000FF">();</span></li>
<li><span style="color: #000000">$t</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">process</span><span style="color: #0000FF">(&nbsp;</span><span style="color: #335533">"hello_world.ezt"&nbsp;</span><span style="color: #0000FF">);</span></li>
<li><span style="color: #000000">?&gt;</span></li>

</ol><p>If you try to copy/paste and run this example, you'll probably get the following output:</p><code class="block">Fatal error: Uncaught exception '<a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateFileNotFoundException.html'>ezcTemplateFileNotFoundException</a>' with message
'The requested template file &lt;/usr/share/templates/hello_world.ezt&gt; does not exist.'</code><p>This error shows that the Template engine looks in the "/usr/share/templates" directory for the templates. If the <em>hello_world.ezt</em> template was present at <em>/usr/share/templates/</em> then the Template engine tries to write to the <em>/tmp/compiled_templates/</em> directory. Make sure that this directory is writable by the current running PHP process. Under Linux the following code makes the directory accessible for anyone:</p><code class="block">mkdir /tmp/compiled_templates
chmod a+rwx /tmp/compiled_templates</code><p>The <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplate.html'>ezcTemplate</a> class calls the getInstance() method from the <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateConfiguration.html'>ezcTemplateConfiguration</a> class and retrieves the "default" configuration. It is possible to set multiple configurations, which is demonstrated in the next example:</p><ol class="code">
<li><span style="color: #000000">&lt;?php</span></li>
<li><span style="color: #0000FF">require_once&nbsp;</span><span style="color: #335533">'tutorial_autoload.php'</span><span style="color: #0000FF">;</span></li>
<li></li>
<li><span style="color: #000000">$t&nbsp;</span><span style="color: #0000FF">=&nbsp;new&nbsp;</span><span style="color: #000000"><a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplate.html'>ezcTemplate</a></span><span style="color: #0000FF">();</span></li>
<li></li>
<li><span style="color: #007700">//&nbsp;Set&nbsp;the&nbsp;template&nbsp;configuration&nbsp;for&nbsp;printer&nbsp;templates.</span></li>
<li><span style="color: #000000">$c&nbsp;</span><span style="color: #0000FF">=&nbsp;</span><span style="color: #000000"><a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateConfiguration.html#getInstance'>ezcTemplateConfiguration::getInstance</a></span><span style="color: #0000FF">(&nbsp;</span><span style="color: #335533">"printer"&nbsp;</span><span style="color: #0000FF">);</span></li>
<li></li>
<li><span style="color: #000000">$c</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">templatePath&nbsp;</span><span style="color: #0000FF">=&nbsp;</span><span style="color: #335533">"printer"</span><span style="color: #0000FF">;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #007700">//&nbsp;./printer&nbsp;directory;</span></li>
<li><span style="color: #000000">$c</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">context&nbsp;</span><span style="color: #0000FF">=&nbsp;new&nbsp;</span><span style="color: #000000"><a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateNoContext.html'>ezcTemplateNoContext</a></span><span style="color: #0000FF">();&nbsp;&nbsp;</span><span style="color: #007700">//&nbsp;Use&nbsp;a&nbsp;context&nbsp;that&nbsp;doesn't&nbsp;do&nbsp;anything.</span></li>
<li></li>
<li><span style="color: #000000">$c&nbsp;</span><span style="color: #0000FF">=&nbsp;</span><span style="color: #000000"><a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateConfiguration.html#getInstance'>ezcTemplateConfiguration::getInstance</a></span><span style="color: #0000FF">();</span></li>
<li><span style="color: #000000">$c</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">templatePath&nbsp;</span><span style="color: #0000FF">=&nbsp;</span><span style="color: #335533">"html"</span><span style="color: #0000FF">;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #007700">//&nbsp;./html&nbsp;directory.</span></li>
<li></li>
<li></li>
<li><span style="color: #007700">//&nbsp;And&nbsp;another&nbsp;way&nbsp;to&nbsp;configure&nbsp;your&nbsp;template&nbsp;engine.</span></li>
<li><span style="color: #000000">$pdfConf&nbsp;</span><span style="color: #0000FF">=&nbsp;new&nbsp;</span><span style="color: #000000"><a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateConfiguration.html'>ezcTemplateConfiguration</a></span><span style="color: #0000FF">(&nbsp;</span><span style="color: #335533">"pdf"</span><span style="color: #0000FF">,&nbsp;</span><span style="color: #335533">"."</span><span style="color: #0000FF">,&nbsp;new&nbsp;</span><span style="color: #000000"><a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateNoContext.html'>ezcTemplateNoContext</a></span><span style="color: #0000FF">()&nbsp;);</span></li>
<li></li>
<li></li>
<li><span style="color: #0000FF">try</span></li>
<li><span style="color: #0000FF">{</span></li>
<li><span style="color: #0000FF">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #007700">//&nbsp;Uses&nbsp;the&nbsp;default&nbsp;configuration.</span></li>
<li><span style="color: #007700">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #000000">$t</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">process</span><span style="color: #0000FF">(&nbsp;</span><span style="color: #335533">"hello_world.ezt"&nbsp;</span><span style="color: #0000FF">);</span></li>
<li><span style="color: #0000FF">}</span></li>
<li><span style="color: #0000FF">catch&nbsp;(&nbsp;</span><span style="color: #000000">Exception&nbsp;$e&nbsp;</span><span style="color: #0000FF">)</span></li>
<li><span style="color: #0000FF">{</span></li>
<li><span style="color: #0000FF">&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;</span><span style="color: #000000">$e</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">getMessage</span><span style="color: #0000FF">()&nbsp;.&nbsp;</span><span style="color: #335533">"\n\n"</span><span style="color: #0000FF">;</span></li>
<li><span style="color: #0000FF">}</span></li>
<li></li>
<li><span style="color: #0000FF">try</span></li>
<li><span style="color: #0000FF">{</span></li>
<li><span style="color: #0000FF">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #007700">//&nbsp;Uses&nbsp;the&nbsp;printer&nbsp;configuration</span></li>
<li><span style="color: #007700">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #000000">$t</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">process</span><span style="color: #0000FF">(&nbsp;</span><span style="color: #335533">"hello_world.ezt"</span><span style="color: #0000FF">,&nbsp;</span><span style="color: #000000"><a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateConfiguration.html#getInstance'>ezcTemplateConfiguration::getInstance</a></span><span style="color: #0000FF">(&nbsp;</span><span style="color: #335533">"printer"&nbsp;</span><span style="color: #0000FF">)&nbsp;);</span></li>
<li><span style="color: #0000FF">}</span></li>
<li><span style="color: #0000FF">catch&nbsp;(&nbsp;</span><span style="color: #000000">Exception&nbsp;$e&nbsp;</span><span style="color: #0000FF">)</span></li>
<li><span style="color: #0000FF">{</span></li>
<li><span style="color: #0000FF">&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;</span><span style="color: #000000">$e</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">getMessage</span><span style="color: #0000FF">()&nbsp;.&nbsp;</span><span style="color: #335533">"\n\n"</span><span style="color: #0000FF">;</span></li>
<li><span style="color: #0000FF">}</span></li>
<li></li>
<li><span style="color: #0000FF">try</span></li>
<li><span style="color: #0000FF">{</span></li>
<li><span style="color: #0000FF">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #007700">//&nbsp;Uses&nbsp;the&nbsp;PDF&nbsp;configuration.</span></li>
<li><span style="color: #007700">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #000000">$t</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">configuration&nbsp;</span><span style="color: #0000FF">=&nbsp;</span><span style="color: #000000">$pdfConf</span><span style="color: #0000FF">;</span></li>
<li><span style="color: #0000FF">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #000000">$t</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">process</span><span style="color: #0000FF">(&nbsp;</span><span style="color: #335533">"hello_world.ezt"&nbsp;</span><span style="color: #0000FF">);</span></li>
<li><span style="color: #0000FF">}</span></li>
<li><span style="color: #0000FF">catch&nbsp;(&nbsp;</span><span style="color: #000000">Exception&nbsp;$e&nbsp;</span><span style="color: #0000FF">)</span></li>
<li><span style="color: #0000FF">{</span></li>
<li><span style="color: #0000FF">&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;</span><span style="color: #000000">$e</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">getMessage</span><span style="color: #0000FF">()&nbsp;.&nbsp;</span><span style="color: #335533">"\n\n"</span><span style="color: #0000FF">;</span></li>
<li><span style="color: #0000FF">}</span></li>
<li><span style="color: #000000">?&gt;</span></li>

</ol><p>Running this example will produce the following output:</p><code class="block">The requested template file &lt;html/hello_world.ezt&gt; does not exist.

The requested template file &lt;printer/hello_world.ezt&gt; does not exist.

The requested template file &lt;pdf/hello_world.ezt&gt; does not exist.</code><p>As demonstrated, the Template configuration can be set in the 'configuration' property, given as second parameter in the process method, or use the 'default' getInstance configuration.</p><a name="lazy-initialization"></a><a name="id8"></a><h4>Lazy initialization</h4><p>Lazy initialization is a mechanism to load and configure a component, only when it is really used in your application. This mechanism saves time for parsing the classes and configuration, when the component is not used at all during one request. You can find a description how you can use it for your own components and how it works in the <a href="introduction_Base.html#lazy-initialization">ezcBase tutorial</a>. The keyword for the template component is <em>ezcInitTemplateConfiguration</em>.</p><ol class="code">
<li><span style="color: #000000">&lt;?php</span></li>
<li><span style="color: #0000FF">require_once&nbsp;</span><span style="color: #335533">'tutorial_autoload.php'</span><span style="color: #0000FF">;</span></li>
<li></li>
<li><span style="color: #0000FF">class&nbsp;</span><span style="color: #000000">customLazyTemplateConfiguration&nbsp;</span><span style="color: #0000FF">implements&nbsp;</span><span style="color: #000000">ezcBaseConfigurationInitializer</span></li>
<li><span style="color: #0000FF">{</span></li>
<li><span style="color: #0000FF">&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;function&nbsp;</span><span style="color: #000000">configureObject</span><span style="color: #0000FF">(&nbsp;</span><span style="color: #000000">$cfg&nbsp;</span><span style="color: #0000FF">)</span></li>
<li><span style="color: #0000FF">&nbsp;&nbsp;&nbsp;&nbsp;{</span></li>
<li><span style="color: #0000FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #000000">$cfg</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">templatePath&nbsp;</span><span style="color: #0000FF">=&nbsp;</span><span style="color: #335533">"/usr/share/templates"</span><span style="color: #0000FF">;</span></li>
<li><span style="color: #0000FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #000000">$cfg</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">compilePath&nbsp;</span><span style="color: #0000FF">=&nbsp;</span><span style="color: #335533">"/tmp/compiled_templates"</span><span style="color: #0000FF">;</span></li>
<li><span style="color: #0000FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #000000">$cfg</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">context&nbsp;</span><span style="color: #0000FF">=&nbsp;new&nbsp;</span><span style="color: #000000"><a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateXhtmlContext.html'>ezcTemplateXhtmlContext</a></span><span style="color: #0000FF">();</span></li>
<li><span style="color: #0000FF">&nbsp;&nbsp;&nbsp;&nbsp;}</span></li>
<li><span style="color: #0000FF">}</span></li>
<li></li>
<li><span style="color: #000000"><a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcBaseInit.html#setCallback'>ezcBaseInit::setCallback</a></span><span style="color: #0000FF">(&nbsp;</span></li>
<li><span style="color: #0000FF">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #335533">'<a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcInitTemplateConfiguration.html'>ezcInitTemplateConfiguration</a>'</span><span style="color: #0000FF">,&nbsp;</span></li>
<li><span style="color: #0000FF">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #335533">'customLazyTemplateConfiguration'</span></li>
<li><span style="color: #0000FF">);</span></li>
<li></li>
<li><span style="color: #000000">$t&nbsp;</span><span style="color: #0000FF">=&nbsp;new&nbsp;</span><span style="color: #000000"><a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplate.html'>ezcTemplate</a></span><span style="color: #0000FF">();</span></li>
<li><span style="color: #000000">$t</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">process</span><span style="color: #0000FF">(&nbsp;</span><span style="color: #335533">"hello_world.ezt"&nbsp;</span><span style="color: #0000FF">);</span></li>
<li><span style="color: #000000">?&gt;</span></li>

</ol><p>This examples shows how to configure the template component like shown in the first example. The main difference is, that we roll out the configuration to an own class, and define a callback using <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcBaseInit.html'>ezcBaseInit</a>::setCallback to this class, which will be called with a template configuration object as first parameter on the first instantiation of the template component.</p><p>ezcBaseInit::setCallback accepts as a first parameter a component specific key, which lets the component later request the right configuration callback. The second parameter is the name of the class to perform the static callback on. This class must implement the <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcBaseConfigurationInitializer.html'>ezcBaseConfigurationInitializer</a> class. Each component's lazy initialization calls the static method configureObject() on the referenced class.</p><p>When the template component is finally instantiated in line 19 of the example, the configureObject() method will be called with an <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateConfiguration.html'>ezcTemplateConfiguration</a> instance used by the Template engine, which can be modified by the method.</p><a name="send-and-receive-template-variables"></a><a name="id9"></a><h4>Send and receive template variables</h4><p>More often than not a PHP application sends variables to the Template engine. Commonly those variables are displayed. It is also possible to retrieve variables from a template. The next example sends two variables to a template. The values are added and placed in a new variable that is returned. The code below is the PHP code needed to send the variables to the template.</p><ol class="code">
<li><span style="color: #000000">&lt;?php</span></li>
<li><span style="color: #0000FF">require_once&nbsp;</span><span style="color: #335533">'tutorial_autoload.php'</span><span style="color: #0000FF">;</span></li>
<li></li>
<li><span style="color: #000000">$t&nbsp;</span><span style="color: #0000FF">=&nbsp;new&nbsp;</span><span style="color: #000000"><a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplate.html'>ezcTemplate</a></span><span style="color: #0000FF">();</span></li>
<li></li>
<li><span style="color: #000000">$t</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">send</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">a&nbsp;</span><span style="color: #0000FF">=&nbsp;</span><span style="color: #000000">2</span><span style="color: #0000FF">;</span></li>
<li><span style="color: #000000">$t</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">send</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">b&nbsp;</span><span style="color: #0000FF">=&nbsp;</span><span style="color: #000000">3</span><span style="color: #0000FF">;</span></li>
<li></li>
<li><span style="color: #007700">//&nbsp;Process&nbsp;it.&nbsp;</span></li>
<li><span style="color: #000000">$t</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">process</span><span style="color: #0000FF">(&nbsp;</span><span style="color: #335533">"tutorial_variable_send_receive.ezt"&nbsp;</span><span style="color: #0000FF">);</span></li>
<li></li>
<li><span style="color: #007700">//&nbsp;Retrieve&nbsp;the&nbsp;$answer&nbsp;variable&nbsp;from&nbsp;the&nbsp;template.&nbsp;</span></li>
<li><span style="color: #0000FF">echo&nbsp;</span><span style="color: #335533">"Answer:&nbsp;"&nbsp;</span><span style="color: #0000FF">.&nbsp;</span><span style="color: #000000">$t</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">receive</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">answer&nbsp;</span><span style="color: #0000FF">.&nbsp;</span><span style="color: #335533">"\n"</span><span style="color: #0000FF">;</span></li>
<li></li>
<li><span style="color: #007700">//&nbsp;Show&nbsp;the&nbsp;output.</span></li>
<li><span style="color: #0000FF">echo&nbsp;</span><span style="color: #000000">$t</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">output</span><span style="color: #0000FF">;</span></li>
<li><span style="color: #000000">?&gt;</span></li>

</ol><p>The template code is as follows:</p><code class="block">{use $a, $b}

{var $answer = $a + $b}

{return $answer}
</code><p>As you can expect the result is:</p><code class="block">Answer: 5</code><a name="template-locations"></a><a name="id10"></a><h4>Template locations</h4><p>Since version 1.2 it is possible to send a location object instead of a <em>location</em> parameter of the <em>process</em> method. A location object is an object that implements the <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateLocation.html'>ezcTemplateLocation</a> interface. The interface is as follows:</p><code class="block">interface <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateLocation.html'>ezcTemplateLocation</a>
{
    public function getPath();
}</code><p>The Template engine calls the <em>getPath</em> method on the object implementing this interface when needed. The <em>getPath</em> method returns a string specifying the template to execute. If the return value is a relative path, if it does not start with a slash, then the <em>templatePath</em> from the configuration is prepended.</p><p>The next example executes the <em>hello_world.ezt</em> template via a location object:</p><code class="block">class MyLocation implements <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateLocation.html'>ezcTemplateLocation</a>
{
    public function getPath()
    {
        return "hello_world.ezt";
    }
}

$t = new <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplate.html'>ezcTemplate</a>();
$t-&gt;process( new MyLocation() );</code><p>It is also possible to provide a callback for every time a template's location is requested. Instead of supplying an object to the process() method of the <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplate.html'>ezcTemplate</a> object like we do above we configure the callback with the template system's configuration:</p><code class="block">$c = <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateConfiguration.html#getInstance'>ezcTemplateConfiguration::getInstance</a>( 'templates' );
$c-&gt;locator = new PathResolver();</code><p>The PathResolver class implements the <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateLocator.html'>ezcTemplateLocator</a> interface and is responsible for translating the paths that processed by the template engine. In the example below it simply prepends "overridden/" to the path. The <em>templatePath</em> from the configuration is prepended. The implementation:</p><code class="block">class PathResolver implements <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateLocator.html'>ezcTemplateLocator</a>
{
    public function translatePath( $path )
    {
        return 'overridden/'. $path;
    }
}</code><p>For every path that now passes through the template engine, "overridden/" is prepended. Which means that the following code actually processes "overridden/test1.ezt":</p><code class="block">$template = new <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplate.html'>ezcTemplate</a>();
$out = $template-&gt;process( 'test1.ezt', $c );</code><a name="template-syntax"></a><a name="id11"></a><h3>Template syntax</h3><p>This section explains the syntax that can be used in the template itself.</p><a name="basic-syntax"></a><a name="id12"></a><h4>Basic syntax</h4><p>The Template engine considers statements embedded in curly braces '{ .. }' as code.  Everything outside a block is parsed as text. The following example shows a template that does a simple calculation:</p><code class="block">5 times 3 equals: { 5*3 }</code><p>This example consists of two parts. The first part is the text up to the opening curly brace. The second part is the code between the braces. Text outside braces will always be printed. The code inside braces will be executed. If the code does not modify a variable then the output of the executed code will also be printed. The example will of course print:</p><code class="block">5 times 3 equals: 15</code><p>Curly braces separate text from template code. Therefore these braces cannot be used in the text directly. To use curly braces there are several possibilities. The most common are to use escape characters or use the literal tag.</p><a name="escape-characters"></a><a name="id13"></a><h5>Escape characters</h5><p>A character can be escaped with a backslash (\). In the text, there are three groups of sequences that can be escaped. Those are:</p><ul><li><p>Open and close curly braces: '\{' turns into '{' and '\}' turns into '}'.</p></li><li><p>The escape character, backslash: '\\' turns into '\'.</p></li><li><p>All newline character combinations: '\[LF]', '\[CR]' and '\[CR][LF]' all turn into '' (nothing).</p></li></ul><p>The next example shows how to escape those characters:</p><code class="block">Draw line: \{ (4, 10), (3, 5) \}
Game path: C:\\Program files\\games\\
Multiple \
lines \
becomes one</code><p>The output of the template is without the backslash and the characters appear normally:</p><code class="block">Draw line: { (4, 10), (3, 5) }
Game path: C:\Program files\games\
Multiple lines becomes one</code><p>All other uses of the escape character '\' result in the escape character being printed. This includes '\' <em>just</em> before an EOF.</p><a name="literal-tags"></a><a name="id14"></a><h5>Literal tags</h5><p>Literal tags are used when the text needs to be processed as it is (literally). The curly braces don't need to be escaped and escape characters can be used. Usually javascript is surrounded by literal tags in the templates. The curly braces don't need to be escaped.</p><p>The next example demonstrates how the escaped characters from the previous example can be omitted with literal tags:</p><code class="block">{literal}
Draw line: { (4, 10), (3, 5) }
Game path: C:\Program files\games\
{/literal}</code><a name="comments"></a><a name="id15"></a><h4>Comments</h4><p>Comments are text blocks which are stripped away from the output when the template is compiled and executed. The Template engine supports three types of comments:</p><ul><li><p>Code comments start and end with, respectively, '{*' and  '*}' tags.</p></li><li><p>Multi-line in-line comment, starts with '/*' and ends with '*/'.</p></li><li><p>Single-line in-line comment that starts with '//' and reads until the end of the line or until a closing curly brace '}'.</p></li></ul><a name="code-comments"></a><a name="id16"></a><h5>Code comments</h5><p>Code comments start and end with:'{*' and  '*}' tags, respectively. Everything inside those tags is considered as comment:</p><code class="block">{* Variable $i alternates the value 0 and 1 *}
{$i = 1 - $i}

{* {if $i == 0}
      {$i = 1}
   {else}
      {$i = 0}
   {/if}
*}</code><p>Writing only <em>{$i = 1 - $i}</em> would have had the same output.</p><a name="multi-line-in-line-comment"></a><a name="id17"></a><h5>Multi-line in-line comment</h5><p>Multi-line in-line comments are created using /* and */. Use this comment to comment a part of a line or comment multiple lines:</p><code class="block">{var $a = 1, /*$b = 2, */ $c = 3 }

{$a = 2, /*
 $b = 3,
 $c = 4
 */}</code><p>If the result after removing the in-line comments is an empty block then the block will be ignored. The next example has an empty block that won't be visible in the output:</p><code class="block">{ /* var $a = 1 */ }</code><p>And is of course the same as writing: <em>{ }</em>. The empty block will be ignored.</p><a name="single-line-in-line-comment"></a><a name="id18"></a><h5>Single-line in-line comment</h5><p>Single-line in-line comments are created using two slashes: // . Use this to start a comment which continues to the end of the line or until the closing curly brace '}':</p><code class="block">{var $a = 1, // $b = 2,
 $c = 3}

{$a = 4 //, $b = 5, $c = 6}</code><p>This example declares the variables <em>$a</em> and <em>$c</em> and assigns in the second statement the value 4 to variable <em>$a</em>.</p><a name="primitive-types"></a><a name="id19"></a><h4>Primitive types</h4><p>The Template language supports several primitive types:</p><a name="boolean"></a><a name="id20"></a><h5>Boolean</h5><p>The boolean type contains either the value: <em>true</em> or the value <em>false</em>. The next example set the <em>$isValid</em> variable to <em>true</em>.</p><code class="block">{var $isValid = true}</code><p>Some of the operators return boolean values. An example is the '==' operator. The <a href="#expressions">Expressions</a> section discusses the operators in more detail. The next example uses the '==' operator:</p><code class="block">{var $isValid = ($number == 6) }</code><p>It checks first whether the variable <em>$number</em> is equal to the value 6. The result is either <em>true</em> or <em>false</em>.  The result is assigned to the variable <em>$isValid</em>.</p><a name="integer"></a><a name="id21"></a><h5>Integer</h5><p>Integers are specified in a decimal notation only. To use octals or hexadimals the number needs to be converted with the appropriate function. Examples are:</p><code class="block">{2}
{4}
{math_hex_to_dec("1F")}</code><p>See the methods: math_bin_to_dec, math_hex_to_dec, math_oct_to_dec, math_dec_to_bin, ath_dec_to_hex, and math_dec_to_oct for more information about those conversions.</p><a name="float"></a><a name="id22"></a><h5>Float</h5><p>Floating point numbers are values that contain a real value. Some examples:</p><code class="block">{1.0}
{-100.234214}
{3.14}</code><p>It is also possible to express an exponent in the float. The exponent is marked with the character 'e' or 'E' followed by one or more digits:</p><code class="block">{1.0e3   // 1000  }
{2e4     // 20000 }
{1e-2    // 0.01  }
{0.1e-2  // 0.001 }
{-3.1e2  // -310  }</code><a name="string"></a><a name="id23"></a><h5>String</h5><p>The string consist of a series of characters enclosed between single or double quotes:</p><code class="block">{'a string'    // Using single quotes }
{"hello world" // Using double quotes }</code><p>In the string we use the backslash (\) as escape character. For the single quoted string the escape characters are:</p><table><tbody><tr><td><p class="cell"><strong>String</strong></p></td><td><p class="cell"><strong>Output</strong></p></td></tr><tr><td><p class="cell">'</p></td><td><p class="cell">'</p></td></tr><tr><td><p class="cell">\ \</p></td><td><p class="cell">\</p></td></tr><tr><td><p class="cell">\</p></td><td><p class="cell">\</p></td></tr></tbody></table><p>Examples of the single quoted strings are:</p><code class="block">{'This string contains a \'quotes\' and backslashes (\\).'}
{'A single \ works also.'}
{'Characters like \n, \t, ", {, }, $, etc can be used without problems'}</code><p>The double quoted string allows more special characters than the single quoted string. Most useful escape characters are probably the variables and newlines that can be included in the string.  The escape characters for the double quoted strings are:</p><table><tbody><tr><td><p class="cell"><strong>String</strong></p></td><td><p class="cell"><strong>Output</strong></p></td></tr><tr><td><p class="cell">"</p></td><td><p class="cell">"</p></td></tr><tr><td><p class="cell">\ \</p></td><td><p class="cell">\</p></td></tr><tr><td><p class="cell">\</p></td><td><p class="cell">\</p></td></tr><tr><td><p class="cell">\n</p></td><td><p class="cell">&lt;newline&gt;</p></td></tr><tr><td><p class="cell">\t</p></td><td><p class="cell">&lt;tab&gt;</p></td></tr><tr><td><p class="cell">$</p></td><td><p class="cell">$</p></td></tr><tr><td><p class="cell">\r</p></td><td><p class="cell">&lt;carriage return&gt;</p></td></tr></tbody></table><p>The next example inserts newlines in the string:</p><code class="block">{"Hello\nHello"}</code><p>The output of the template above is:</p><code class="block">Hello
Hello</code><p>Some other examples of using single and double quoted strings:</p><code class="block">{" a \"quoted\" string "}
{'Newlines are added with the \\n command.'}
{'\tThis string starts with a tab (\\t).'}</code><a name="array"></a><a name="id24"></a><h5>Array</h5><p>The array is just like in PHP an ordered map. It can be used as an array or as a table that maps values to keys. There are two ways to create an array. The first method has the following syntax:</p><code class="block">array( [ key =&gt; ] value, [ key2 =&gt; ] value2, ... )</code><p>The parts between brackets are optional. So the <em>key</em> can be omitted. In that case, it would simply create an array.  First value has the index 0, the next value has index 1, and so on. The next example creates an array which consists of 3 elements:</p><code class="block">{var $names = array( "Bernard", "Manny", "Fran" )}</code><p>The array values, and in this case the names, can be accessed:</p><code class="block">{$names[0] // Outputs "Bernard"}
{$names[2] // Outputs "Fran"}
{$names[3] // Is not allowed }</code><p>The array with <em>keys</em> maps the key to a value:</p><code class="block">{var $personInfo = array( "first_name" =&gt; "Bernard", "last_name" =&gt; "Black" ) }</code><p>To access the information:</p><code class="block">{$personInfo["first_name"] // Outputs "Bernard"}
{$personInfo["last_name"] // Outputs "Black"}</code><p>The second method to create an array is to use the <em>..</em> (dot-dot) operator</p><code class="block">&lt;number1&gt;..&lt;number2&gt;</code><p>The operator creates an array that contains the numbers from <em>number1</em> to <em>number2</em>. The next example creates an array that contains the numbers: 3, 4, 5, 6, and 7.</p><blockquote><p>{var $nrs = 3..7 } {$nrs[0] // Outputs 3}</p></blockquote><p>This method is especially useful to use in a foreach loop. The following example loops 10 times, and prints the number from 1 until 10:</p><code class="block">{foreach 1..10 as $i}
    Number: {$i}
{/foreach}</code><p>The <a href="#foreach">Foreach</a> section describes this loop in more detail.</p><a name="object"></a><a name="id25"></a><h5>Object</h5><p>Objects are only available when they are sent from the user application. It is not possible to create an object inside the Template language. The template language restricts the accessibilities from the object only to its properties; thus function calls are not permitted.  The next example is a part of an user application that sends an object to a template:</p><ol class="code">
<li><span style="color: #000000">&lt;?php</span></li>
<li></li>
<li><span style="color: #0000FF">class&nbsp;</span><span style="color: #000000">MyClass</span></li>
<li><span style="color: #0000FF">{</span></li>
<li><span style="color: #0000FF">&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;&nbsp;</span><span style="color: #000000">__get</span><span style="color: #0000FF">(&nbsp;</span><span style="color: #000000">$name&nbsp;</span><span style="color: #0000FF">)</span></li>
<li><span style="color: #0000FF">&nbsp;&nbsp;&nbsp;{</span></li>
<li><span style="color: #0000FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;</span><span style="color: #335533">"Hello&nbsp;</span><span style="color: #000000">$name</span><span style="color: #335533">"</span><span style="color: #0000FF">;</span></li>
<li><span style="color: #0000FF">&nbsp;&nbsp;&nbsp;}</span></li>
<li></li>
<li><span style="color: #0000FF">&nbsp;&nbsp;&nbsp;public&nbsp;function&nbsp;</span><span style="color: #000000">__set</span><span style="color: #0000FF">(&nbsp;</span><span style="color: #000000">$name</span><span style="color: #0000FF">,&nbsp;</span><span style="color: #000000">$value&nbsp;</span><span style="color: #0000FF">)</span></li>
<li><span style="color: #0000FF">&nbsp;&nbsp;&nbsp;{</span></li>
<li><span style="color: #0000FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;</span><span style="color: #000000">Exception&nbsp;</span><span style="color: #0000FF">(</span><span style="color: #335533">"Setting&nbsp;</span><span style="color: #000000">$name</span><span style="color: #335533">&nbsp;is&nbsp;not&nbsp;allowed"</span><span style="color: #0000FF">);</span></li>
<li><span style="color: #0000FF">&nbsp;&nbsp;&nbsp;}</span></li>
<li><span style="color: #0000FF">}</span></li>
<li></li>
<li><span style="color: #000000">$t&nbsp;</span><span style="color: #0000FF">=&nbsp;new&nbsp;</span><span style="color: #000000"><a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplate.html'>ezcTemplate</a></span><span style="color: #0000FF">();</span></li>
<li><span style="color: #000000">$t</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">send</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">obj&nbsp;</span><span style="color: #0000FF">=&nbsp;new&nbsp;</span><span style="color: #000000">MyClass</span><span style="color: #0000FF">;&nbsp;</span><span style="color: #007700">//&nbsp;Create&nbsp;an&nbsp;object&nbsp;and&nbsp;assign&nbsp;it&nbsp;to&nbsp;"obj"</span></li>
<li><span style="color: #000000">$t</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">process</span><span style="color: #0000FF">(</span><span style="color: #335533">"my_template.ezt"</span><span style="color: #0000FF">);</span></li>
<li></li>
<span style="color: #000000">?&gt;</span>
</ol><p>The class in the example above has two 'magic' PHP functions. Fetching any property is allowed, whereas setting a property value throws an Exception. The template code that belongs to the user application:</p><code class="block">{use $obj // Import the "obj" }

{$obj-&gt;Bernard // Calls the  __get method on the object which returns "Hello Bernard"}
{$obj-&gt;Bernard = "Fran" // Calls the __set method that throws an exception}</code><p>More information about importing objects is described in the <a href="#external-variable-declaration-use">External variable declaration (use)</a> section.</p><a name="variables"></a><a name="id26"></a><h4>Variables</h4><p>A variable can only be used after it has been declared. A declaration defines a unique variable name that will be available from now until the end of the template. The next example declares a local variable:</p><code class="block">{* Declare the variable *}
{var $the_answer_to_life_the_universe_and_everything}

{* Assign it to 42 *}
{$the_answer_to_life_the_universe_and_everything = 42}</code><p>Switching the assignment with the declaration results in a compiler error.</p><p>Variables in the syntax languages are represented by a dollar sign followed by the name of the variable. The variable name is case-sensitive. A valid variable name starts with a letter or underscore, followed by any number of letters, numbers, or underscores:</p><code class="block">{* valid declarations *}
{var $abcdEFG}
{var $_hello_}
{var $hello12}

{* invalid declarations *}
{var $12monkeys}
{var $dumb&amp;dumber *}</code><p>The Template language has three types of variable declaration: <em>var</em>, <em>use</em> and <em>cycle</em>. <em>Var</em> declares a local variable as used in the previous example, <em>use</em> imports an external variable, and <em>cycle</em> declares a cycle variable.</p><a name="local-variable-declaration-var"></a><a name="id27"></a><h5>Local variable declaration (var)</h5><p>The declaration of a local variable creates a variable that has only a value inside the current template.</p><p>The syntax to declare a local variable is:</p><code class="block">{var $&lt;unique_name&gt; [ = &lt;value&gt; ] [ , $&lt;unique_name2&gt; [ = &lt;value&gt; ] ] }</code><p>One or multiple variables can be declared with one <em>var</em> statement. A value can be assigned to the variable name, directly. If no value is given to the variable, then it will get the default value <em>null</em>.</p><p>The next example declares four variables at the same time:</p><code class="block">{var $a = 2, $b = "Hello World", $c = true, $d}</code><p>All variables are initialized to a value. (The last variable is initialized to <em>null</em>.)</p><a name="external-variable-declaration-use"></a><a name="id28"></a><h5>External variable declaration (use)</h5><p>The declaration of an external variable creates a variable that usually has a value from outside the current template. Outside the current template is, for example, the application that compiles and executes the template.</p><p>The syntax for this type of variable is as follows:</p><code class="block">{use $&lt;unique_name&gt; [ = &lt;value&gt; ] [ , $&lt;unique_name2&gt; [ = &lt;value&gt; ] ] }</code><p>Besides the <em>use</em> tag it is the same syntax as a local variable declartion.</p><p>The variable will be imported from the user application or another template and is now available in the current template. If the declared <em>use</em> variable is not sent to the current template an exception will be raised <strong>unless</strong> the declared variable is initialized to a value.</p><code class="block">{use $a, $b = 2}</code><p>Variable <em>$b</em> will be assigned to the value <em>2</em> if the variable is not sent to the template. Variable <em>$a</em> will raise an Exception when the variable is not sent.</p><p>The next example shows a part of the user application:</p><code class="block">$t = new <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplate.html'>ezcTemplate</a>();

// Send some information to the Template
$t-&gt;send-&gt;item1 = "Toaster";
$t-&gt;send-&gt;item2 = "Manny";

// Process the template and print it.
echo $t-&gt;process();</code><p>The variables $item1 and $item2 are now available in the template if they are declared with <em>use</em>:</p><code class="block">{use $item1 = "unknown", $item2 = "unknown"}

Use {$item1} on {$item2}</code><a name="cycles"></a><a name="id29"></a><h5>Cycles</h5><p>A cycle is a special type of variable that contains a set of values. The cycle variable must be assigned to an array. Values are retrieved one array element at the time.  Specific control structures are available to cycle through the set of values. The syntax for the cycle is:</p><code class="block">{cycle $&lt;unique_name&gt; [ = &lt;array_value&gt; ] [ , $&lt;unique_name2&gt; [ = &lt;array_value&gt; ] ] }</code><p>An array must be assigned to the cycle variable. Otherwise the template compiler <em>may</em> give a compiler error. (Sometimes it is not possible to know at compile time whether the assignment is an array or not.)</p><p>The next example declares a cycle, assigns a value, and retrieves the first and second value:</p><code class="block">{cycle $rgb = array( "red", "green", "blue" ) }

{$rgb // Print "red"}
{$rgb // Print "red"}
{increment $rgb // Go to the next element}

{$rgb // Print "green"}</code><p>See the <a href="#increment">Increment</a>, <a href="#decrement">Decrement</a> and <a href="#reset">Reset</a> section for more information.</p><a name="scopes"></a><a name="id30"></a><h5>Scopes</h5><p>Variable declarations must be done at the highest scope of the template. Declaring a variable in a lower scope will result in a compiler error.</p><p>Scopes are usually opened and closed with a start and end template block. Template blocks that open a new scope are: {if .. }{/if}, {while ..} {/while}, {foreach ..} {/foreach}, {switch .. } {/switch}, etc. The next example demonstrates this scoping:</p><code class="block">{var $a = 2  // Correct }

{if 2 == 3}
    {* This opens a new scope *}

    {var $b // ERROR! }
{/if}</code><a name="returning-variables"></a><a name="id31"></a><h5>Returning variables</h5><p>Templates itself can also return variables to the user application or other templates. The return statement defines the variables that need to be returned:</p><code class="block">{return ( &lt;expression&gt; as &lt;variable&gt; | &lt;variable&gt; ) [, ( &lt;expression&gt; as &lt;variable&gt; | &lt;variable&gt; ), ... ] }</code><p>The return statement returns one or multiple variables. The caller of the template can retrieve the return values. Consider the following template:</p><code class="block">{* Return 6! and "Hello world" *}

{var $fac6 = 6 * 5 * 4 * 3 * 2 }
{return $fac6, "Hello world" as $helloWorld}</code><p>The user application can retrieve these values via the receive property of the template. See the next example for a demonstration:</p><code class="block">$t = new <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplate.html'>ezcTemplate</a>();

// Process the template.
$t-&gt;process();

// Retrieve the values from the return.
$fac6 = $t-&gt;receive-&gt;fac6;
$hw   = $t-&gt;receive-&gt;helloWorld;

// Output Hello world:
echo $hw;</code><p>More information about returning variables is described in the <a href="#include">Include</a> section.</p><a name="capturing-content-into-variables"></a><a name="id32"></a><h5>Capturing content into variables</h5><p>Sometimes it's useful to capture a specific part of a template in a variable for reuse. This you can do with the capture statement:</p><code class="block">{var $var}
{capture $var}
Add some content.
{/capture}

Output it a few more times:
{$var}
{$var}</code><p>Be aware that you still have to declare the variable with the {var} block.</p><a name="expressions"></a><a name="id33"></a><h4>Expressions</h4><p>An expression is anything you write in a template block that doesn't start with a special tag. But expressions are also used in template blocks with a tag and gives merely a value. PHP quotes the expression as "Anything that gives a value", that is also true for the template syntax.</p><p>Expressions can be a single <em>operand</em> that returns a value. It is also possible to combine multiple operands with <em>operators</em>. The value returned depends on the used operands and operators.</p><p>The operands are:</p><ul><li><p><a href="#boolean">Boolean</a></p></li><li><p><a href="#integer">Integer</a></p></li><li><p><a href="#float">Float</a></p></li><li><p><a href="#string">String</a></p></li><li><p><a href="#array">Array</a></p></li><li><p><a href="#variables">Variables</a></p></li><li><p><a href="#functions">Functions</a></p></li></ul><p>The operands Boolean, Integer, Float, String, and Array are described in the <a href="#primitive-types">Primitive types</a> section. Variables are described in the <a href="#variables">Variables</a> section. Functions will be described in the <a href="#functions">Functions</a> section.</p><p>Variables and functions are considered as operands since they return one value. The type of this return value is also a: Boolean, Integer, Float, String, or Array.</p><p>An operand returns a single value. Some examples are:</p><code class="block">{5}
{"Hello"}
{str_len("Hello")}</code><p>The values returned are, respectively: 5, Hello, and 5.</p><p>Operators are things that you feed with one or multiple values and will result another value.  Examples of operators are adding two numbers together with the plus (+) operator. This operator expects two integers or floats (in any combination) and returns either a integer of float. Another example is the equal operator (==). It expects two types operands of the same type and returns a Boolean.</p><a name="arithmetic-operators"></a><a name="id34"></a><h5>Arithmetic operators</h5><p>The arithmetic operators can be used on all expressions which return a numerical value. The operator itself returns also a numeric value. The table below describes the available arithmetic operators:</p><table><tbody><tr><td><p class="cell">Negation</p></td><td><p class="cell">-$o</p></td></tr><tr><td><p class="cell">Ignored</p></td><td><p class="cell">+$o</p></td></tr><tr><td><p class="cell">Addition</p></td><td><p class="cell">$ol + $or</p></td></tr><tr><td><p class="cell">Subtraction</p></td><td><p class="cell">$ol - $or</p></td></tr><tr><td><p class="cell">Multiplication</p></td><td><p class="cell">$ol * $or</p></td></tr><tr><td><p class="cell">Division</p></td><td><p class="cell">$ol / $or</p></td></tr><tr><td><p class="cell">Modulus</p></td><td><p class="cell">$ol % $or</p></td></tr></tbody></table><p>Note: The negation in this table is the arithmetic negation. Don't confuse this with the logic negation.</p><p>The unary plus operator can also be used, but it doesn't affect the value. It's usually used to clarify that it's not a negative value.</p><p>Examples:</p><code class="block">{ 2 + 5     // Returns value 7}
{ 2 - 5 }
{ 4 + 3 * 2  // Due to the operator precedence, first the *
             // will be evaluated and thereafter the +. }

{var $a = 2}
{var $b = -$a}</code><a name="comparison-operators"></a><a name="id35"></a><h5>Comparison operators</h5><p>All comparison operators return a boolean value. The left-hand side and right-hand side should be of the same type. The available comparison operators are:</p><table><tbody><tr><td><p class="cell">Equal</p></td><td><p class="cell">$ol == $or</p></td></tr><tr><td><p class="cell">Identical</p></td><td><p class="cell">$ol === $or</p></td></tr><tr><td><p class="cell">Not equal</p></td><td><p class="cell">$ol != $or</p></td></tr><tr><td><p class="cell">Not identical</p></td><td><p class="cell">$ol !== $or</p></td></tr><tr><td><p class="cell">Less than</p></td><td><p class="cell">$ol &lt; $or</p></td></tr><tr><td><p class="cell">Greater than</p></td><td><p class="cell">$ol &gt; $or</p></td></tr><tr><td><p class="cell">Less than or equal</p></td><td><p class="cell">$ol &lt;= $or</p></td></tr><tr><td><p class="cell">Greater than or equal</p></td><td><p class="cell">$ol &gt;= $or</p></td></tr></tbody></table><p>Examples:</p><code class="block">{ 4 == 5 }
{ 2 &lt;= 5 }
{ true != false }
{ 4 == 5 == 6 }</code><p>The last example compares 4 with 5. This returns the boolean <em>false</em>. After the first step the comparison is:</p><code class="block">{ false == 6 }</code><p>The number 6 will be changed into a boolean. Every number except zero will get the boolean value <em>true</em>. Basically the last step of the comparison is:</p><code class="block">{ false == true }</code><p>And this return the boolean value <em>false</em>.</p><a name="logical-operators"></a><a name="id36"></a><h5>Logical operators</h5><p>The logical operators are used on all expressions which return a boolean value. The operator returns also a boolean:</p><table><tbody><tr><td><p class="cell">Not</p></td><td><p class="cell">! $o</p></td></tr><tr><td><p class="cell">And</p></td><td><p class="cell">$ol &amp;&amp; $or</p></td></tr><tr><td><p class="cell">Or</p></td><td><p class="cell">$ol || $or</p></td></tr></tbody></table><p>Some usage examples:</p><code class="block">{ true || false }
{ $a == 5 &amp;&amp; $a != 7 }
{ $a || $b }</code><a name="assignments"></a><a name="id37"></a><h4>Assignments</h4><p>Assignments set a value to a variable. If the variable does already contain a value, it will be overwritten. As explained in the <a href="#variables">Variables</a> section the variable must be declared first. Notice that an assignment can be used in the declaration itself.</p><p>The syntax language has two types of assignments. The former type assigns a new value to the variable:</p><code class="block">{ &lt;variable&gt; = &lt;expression&gt; }</code><p>The expression is evaluated and assigned to the variable. The next example assigns the value 4 to the variable <em>$myVar</em>:</p><code class="block">{var $myVar}
{ $myVar = 3 + 5 / 5 }</code><p>The latter assignment type updates the existing value with a modifier. There are multiple operators available:</p><table><tbody><tr><td><p class="cell">Addition</p></td><td><p class="cell">$var += $or</p></td></tr><tr><td><p class="cell">Subtraction</p></td><td><p class="cell">$var -= $or</p></td></tr><tr><td><p class="cell">Multiplication</p></td><td><p class="cell">$var *= $or</p></td></tr><tr><td><p class="cell">Division</p></td><td><p class="cell">$var /= $or</p></td></tr><tr><td><p class="cell">Modulus</p></td><td><p class="cell">$var %= $or</p></td></tr><tr><td><p class="cell">Pre increment</p></td><td><p class="cell">++$var</p></td></tr><tr><td><p class="cell">Pre decrement</p></td><td><p class="cell">--$var</p></td></tr><tr><td><p class="cell">Post increment</p></td><td><p class="cell">$var++</p></td></tr><tr><td><p class="cell">Post decrement</p></td><td><p class="cell">$var--</p></td></tr></tbody></table><p>The Addition, Subtraction, Multiplication, Division, and Modulus assignment operators do an arithmetic calculation between the left (variable) and the right operand (expression) and assigns the value in the left operand (variable) again. Notice that the variable must already contain a value.</p><p>The increment operators increment the number of the current variable by one. The decrement operators do the opposite and decrement the value of the current variable by one. There is no difference between the pre and post operators, and both are present for convenience purposes.</p><p>Examples:</p><code class="block">{var $myVar = 5 }

{$myVar += 5   // $myVar has the value 10 }
{$myVar++      // is the same as $myVar += 1 }

{$myVar *= 10  // Multiply with 10}
{--$myVar      // Same as: $myVar -= 1 }</code><a name="functions"></a><a name="id38"></a><h4>Functions</h4><p>The Template language has lots of built-in functions. These functions are categorized in a few groups: String, Array, Regular expression, Type information, and Arithmetic (math) functions. The functions are explained in the appendix.</p><p>A function call has the following syntax:</p><code class="block">&lt;function_name&gt; ( [ Parameter1 [, Parameter2, ... ] ] )</code><p>An example:</p><code class="block">{var $res = str_compare( "Hello", "world" ) }
{$res // prints the result}</code><p>All template functions follow these rules:</p><ul><li><p>Function output is always returned. No variables are changed via references.</p></li><li><p>If the function contains a "haystack" and a "needle" then the first parameter will be the "haystack". The "needle parameter is a parameter that operates on another parameter, the "haystack".</p></li></ul><a name="contexts"></a><a name="id39"></a><h4>Contexts</h4><p>The purpose of the context is to simplify the development of the templates and make the templates more secure. The context defines the purpose of the template output. For example the XHTML context should be set for the templates that generate (X)HTML output.</p><p>When a template is processed and executed, it runs in a specific context.  The context is set to XHTML by default. The next example shows a part of a user application that specifies the XHTML context:</p><code class="block">$config = <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateConfiguration.html#getInstance'>ezcTemplateConfiguration::getInstance</a>();
$config-&gt;context = new <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateXhtmlContext.html'>ezcTemplateXhtmlContext</a>();

$t = new <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplate.html'>ezcTemplate</a>();
$t-&gt;process( "hello_world.ezt" );</code><p>Configuring the Template engine is discussed in the tutorial in more detail.</p><p>The available context are described in the next subsections.</p><a name="xhtml-context"></a><a name="id40"></a><h5>XHTML Context</h5><p>The XHTML Context escapes the HTML characters from the output from the expression blocks. Output outside the blocks are not escaped. See the next example:</p><code class="block">{var $lt = "3 &lt; 5"}
&lt;b&gt;{$lt}&lt;/b&gt;</code><p>This template contains the HTML character '&lt;' in an expression block. This character will be escaped. The output of the template is:</p><code class="block">&lt;b&gt;3 &amp;lt 5&lt;/b&gt;</code><p>The escape characters of the XHTML context are:</p><table><thead><tr><th><p class="cell">Character</p></th><th><p class="cell">Translation</p></th></tr></thead><tbody><tr><td><p class="cell">&amp;</p></td><td><p class="cell">&amp;amp;</p></td></tr><tr><td><p class="cell">"</p></td><td><p class="cell">&amp;quot;</p></td></tr><tr><td><p class="cell">&lt;</p></td><td><p class="cell">&amp;lt;</p></td></tr><tr><td><p class="cell">&gt;</p></td><td><p class="cell">&amp;gt;</p></td></tr></tbody></table><p>If the HTML characters in the expression block should not be escaped then the "raw" block should be used. The next example demonstrates a "raw" block:</p><code class="block">{var $myBoldText = "&lt;b&gt;Hello world&lt;/b&gt;"}

{raw $myBoldText}</code><p>This template outputs:</p><code class="block">&lt;b&gt;Hello world&lt;/b&gt;</code><p>See the <a href="#raw">Raw</a> section for more information.</p><a name="additional-required-escaping"></a><a name="id41"></a><h6>Additional required escaping</h6><p>Even inside XHTML there are still different output contexts, which might require different escaping. For example when using variables inside JavaScript the default escaping is <em>not sufficient</em>, but additional characters are required to be escaped, like shown in the following example. If the following template is called with the <code class="inline">$input = '\' ); alert( \' XSS Alert ';</code>, it will show an JavaScript alert box, even with XHTML context escaping:</p><code class="block">{use $input}
&lt;body onLoad="JavaScript: doSomething( '{$input}' );"&gt;
...</code><p>To work around this issue you can either write a custom template function which wraps around the PHP function <code class="inline">addslashes()</code> or do the following in your template:</p><code class="block">{use $input}
&lt;body onLoad="JavaScript: doSomething( '{
    str_find_replace( "'", "\\'",
        str_find_replace( '"', '\\"',
            str_find_replace( '\\', '\\\\', $input )
        )
    )}' );"&gt;
...</code><p>This should be safe afterwards. Remember that there might be other contexts in your XHTML files, like other client side scripting languages, which again require different additional output escaping.</p><a name="no-context"></a><a name="id42"></a><h5>No Context</h5><p>The No Context does not escape any characters. Usefull for text output and testing purposes.</p><a name="control-structures"></a><a name="id43"></a><h4>Control structures</h4><p>Control structures are elements which help you control the flow of the code, either by doing conditional statements or by repeating certain actions.</p><a name="increment"></a><a name="id44"></a><h5>Increment</h5><p>The increment construct sets the cycle variable to the next value in the cycle array:</p><code class="block">{cycle $rgb = array("red", "green", "blue" )}

{$rgb // Print "red" }
{increment $rgb}
{$rgb // Print "green" }</code><p>If the end of the cycle array is reached, it will jump again to the first value of the array.</p><a name="decrement"></a><a name="id45"></a><h5>Decrement</h5><p>The decrement construct sets the cycle variable to the previous value in the cycle array:</p><code class="block">{cycle $rgb = array("red", "green", "blue" )}

{$rgb // Print "red" }
{decrement $rgb}
{$rgb // Print "blue" }</code><p>If the begin of the cycle array is reached, it will jump again to the last value of the array.</p><a name="reset"></a><a name="id46"></a><h5>Reset</h5><p>The reset construct sets the cycle variable to the first value in the cycle array:</p><code class="block">{cycle $rgb = array("red", "green", "blue" )}

{$rgb // Print "red" }
{increment $rgb}
{$rgb // Print "blue" }

{reset $rgb}
{$rgb // Print "red" }</code><a name="if-else-elseif"></a><a name="id47"></a><h5>If, else, elseif</h5><p>The <em>if</em> construct allows conditional execution of code fragments. The structure is:</p><code class="block">{if &lt;expression&gt; }
    &lt;code&gt;
{/if}</code><p>If the &lt;expression&gt; evaluates to true, the &lt;code&gt; fragment will be executed. For instance the following code will show "$a is less than $b" if $a is less than $b:</p><code class="block">{if $a &lt; $b }
    $a is less than $b.
{/if}</code><p>The <em>else</em> construct can be used in an <em>if</em> statement. It contains a code fragment that will be executed if the <em>expression</em> evaluates to false:</p><code class="block">{if expression }
   code1
{else}
   code2
{/if}</code><p>The <em>code2</em> is executed when the expression is false. Otherwise <em>code1</em> is executed.</p><p>The <em>elseif</em> construct can be used in an <em>if</em> statement. It adds an extra expression and code block that will be evaluated and executed when the (previous) expression from the <em>if</em> statement does not evaluate to true:</p><code class="block">{if $weekday == 0}
    Monday
{elseif $weekday == 1}
    Tuesday
{elseif $weekday == 2}
    Wednesday
{else}
    Thursday, Friday, Saturday, or Sunday.
{/if}</code><p>Writing an <em>elseif</em> statement is actually the same as writing them with separate <em>if</em> and <em>else</em> statements. The previous example could be written as:</p><code class="block">{if $weekday == 0}
     Monday
{else}
  {if $weekday == 1}
      Tuesday
  {else}
    {if $weekday == 2}
        Wednesday
    {else}
        Thursday, Friday, Saturday, or Sunday.
    {/if}
  {/if}
{/if}</code><p>As you can see, this makes the code harder to read.</p><a name="switch-case-default"></a><a name="id48"></a><h5>Switch, Case, Default</h5><p>The switch construct is quite similar to multiple <em>if</em> and <em>elseif</em> statements. The syntax is as follows:</p><code class="block">{switch &lt;expression&gt;}

    &lt;case1&gt; [ case2 [ case3, .. ] ]
    [ default ]

{/switch}</code><p>A <em>case</em> block has the following syntax:</p><code class="block">{case &lt;literal&gt; [, &lt;literal&gt;, ..]}
    &lt;code&gt;
{/case}</code><p>And the <em>default</em> is as follows:</p><code class="block">{default}
    &lt;code&gt;
{/default}</code><p>The switch statement expects an expression. This expression will then be compared with the literal values from the <em>case</em> statements. The comparison starts and goes to the next literal as the values from the &lt;expression&gt; and &lt;literal&gt; are not equal. The &lt;code&gt; from the first match will be executed and the rest of the cases are skipped.</p><p>If none of the cases match, then the default block will be executed. See the example switch statement below:</p><code class="block">{switch $weekDay}

    {case 0} Monday {/case}
    {case 1} Tuesday {/case}
    {case 2} Wednesday {/case}
    {case 3, 4, 5, 6}
        Thursday, Friday, Saturday, or Sunday
    {/case}

    {default}
        The $weekDay should be a number between 0 and 6.
    {/default}

 {/switch}</code><p>This switch converts the weekday number to a name.</p><a name="foreach"></a><a name="id49"></a><h5>Foreach</h5><p>A very important construct in the Template language is the <em>foreach</em>. The foreach is a loop structure that iterates over an array. Since this loop is used so often in the templates, it has several convenience tags build in. First we'll show the basic syntax:</p><code class="block">{foreach &lt;array&gt; as &lt;value&gt; }
    &lt;code&gt;
{/foreach}

{foreach &lt;array&gt; as &lt;key&gt; =&gt; &lt;value&gt; }
    &lt;code&gt;
{/foreach}</code><p>Two foreach structures are shown. The first structure takes each element from the <em>array</em>&gt; and assigns it to the variable <em>&lt;value</em>&gt;. The second structure does the same, except that the key of the array is assigned to the variable <em>key</em>.</p><p>An example for each structure:</p><code class="block">{var $rgb = array( "red", "green", "blue" ) }
{foreach $rgb as $color}
  The color is: {$color}
{/foreach}

{foreach $rgb as $key =&gt; $color}
  Array key {$key} contains the color: {$color}
{/foreach}</code><p>The output for this example will be:</p><code class="block">The color is: red
The color is: green
The color is: blue

Array key 0 contains the color: red
Array key 1 contains the color: green
Array key 2 contains the color: blue</code><p>With this syntax we can easily loop any number, and is more convenient than using the <a href="#while">while</a> structure. This is demonstrated next:</p><code class="block">{foreach 1..10 as $i}
Iteration {$i}
{/foreach}</code><p>This works because the <em>1..10</em> statement creates an array with the values from 1 until 10.</p><p>Often a foreach is used to create some kind of table or list. Several extensions are made available to ease the development:</p><p>The foreach loop can have an increment and decrement tag. These tags increment and/or decrement an cycle value, and work exactly the same as the <a href="#increment">Increment</a> and <a href="#decrement">Decrement</a> control structures. The syntax is almost the same in the foreach:</p><code class="block">[increment &lt;variable1&gt; [, variable2, ... ] ]
[decrement &lt;variable1&gt; [, variable2, ... ] ]</code><p>These tags are the same as the <a href="#increment">Increment</a> and <a href="#decrement">Decrement</a> control structures.</p><p>This tag is added at the end of the foreach construct. The next example increments the cycle value in every iteration of the loop:</p><code class="block">{cycle $blackAndWhite = array( '#00000', '#FFFFFF' )}

{foreach 1..5 as $value increment $blackAndWhite}
    &lt;font color="{$blackAndWhite}"&gt;Number: {$value}&lt;/font&gt;
{/foreach}</code><p>This loop outputs the following code:</p><code class="block">&lt;font color="#000000"&gt;Number: 1&lt;/font&gt;
&lt;font color="#FFFFFF"&gt;Number: 2&lt;/font&gt;
&lt;font color="#000000"&gt;Number: 3&lt;/font&gt;
&lt;font color="#FFFFFF"&gt;Number: 4&lt;/font&gt;
&lt;font color="#000000"&gt;Number: 5&lt;/font&gt;</code><p>The offset and limit code constructs are specified after the cycle increment or decrement tag. The offset and limit constructs are extremely useful for splitting a long table or list over multiple page views. The next example demonstrates this:</p><code class="block">{use $hugeArray = array(), $offset = 0}
{foreach $hugeArray as $tableEntry offset $offset limit 100}

  {* Show the information from the $tableEntry *}

{foreach}</code><p>See the <a href="#external-variable-declaration-use">External variable declaration (use)</a> section for more information. The loop will start at the $offset and won't show the previous elements. The maximum iterations of the loop is 100. Another example shows the numbers from 50 until 100:</p><code class="block">{var $hugeArray = 1..1000}

{foreach $hugeArray as $value offset 50 limit 50}
  {$value}
{/foreach}</code><a name="while"></a><a name="id50"></a><h5>While</h5><p>The while loop loops over a code fragment as long as the expression in the while evaluates to true. The syntax of the while loop is as follows:</p><code class="block">{while &lt;expression&gt;}
    &lt;code&gt;
{/while}</code><p>Usually the expression evaluates whether a counter reaches a certain number. In the <em>code</em> the counter is increased or decreased:</p><code class="block">{var $i = 0}
{while $i &lt; 10}
   The number is: {$i}.
   {$i++}
{/while}</code><p>This example prints the numbers from 0 until 9. If you write a while loop, make sure that the loop eventually ends. The next example demonstrates another while loop. This loop increments a value from a Cycle. Compare how the same example can be done with a <a href="#foreach">Foreach</a>:</p><code class="block">{cycle $blackAndWhite = array( '#00000', '#FFFFFF' )}
{var $i = 1}

{while $i &lt;= 5 }
    &lt;font color="{$blackAndWhite}"&gt;Number: {$i}&lt;/font&gt;
    {$i++}
    {increment $blackAndWhite}
{/while}</code><a name="delimiter"></a><a name="id51"></a><h5>Delimiter</h5><p>The delimiter can be used (only) inside a loop to do every given iteration a specific action. The syntax is as follows:</p><code class="block">{delimiter [modulo &lt;expression&gt; [is &lt;expression&gt;]]}
    &lt;code&gt;
{/delimiter}</code><p>The "module...&lt;expression&gt;" part can be omitted and by default the delimiter will be inserted between every iteration of the loop. If a modulo is used, the "is &lt;expression&gt;" part of the delimiter can be omitted and will be interpreted as "is 0".</p><p>The delimiter will always be executed between two iterations of the loop. In the next example between every name a comma is inserted:</p><code class="block">{var $names = array( 'Bernard', 'Fran', 'Manny' )}
{foreach $names as $name}
{$name}
{delimiter}, {/delimiter}
{/foreach}</code><p>The next example demonstrates creates a matrix with 4 rows and 4 columns. The delimiter closes the current row and opens a new one every forth column as the delimiter is only added when "internal counter modulo 4" equals 0. The "internal counter" simply counts the number of executed iterations:</p><code class="block">{var $columns = 4}
&lt;table&gt;
&lt;tr&gt;
{foreach 1..16 as $nr}
  &lt;td&gt;{$nr}&lt;/td&gt;

  {delimiter modulo $columns}
    &lt;/tr&gt;&lt;tr&gt;
  {/delimiter}
{/foreach}
&lt;/tr&gt;</code><a name="continue"></a><a name="id52"></a><h5>Continue</h5><p>The continue statement is used within the looping structures to skip the rest of the current loop iteration and continue execution at the condition evaluation and then the beginning of the next iteration. If a delimiter is available in the looping structure then this delimiter will be added. Use the <a href="#skip">Skip</a> statement to skip also the delimiter.</p><p>The next example show the numbers 1 to 5 separated with a comma. After the numbers 1, 2, and 3 is the token # appended. As the example shows, the numbers higher than 3 will not execute the rest of the foreach anymore. The delimiter is added anyway:</p><code class="block">{foreach 1..5 as $i}

{delimiter}
,
{/delimiter}

{$i}
{if $i &gt; 3} {continue} {/if}
#
{/foreach}</code><p>The output of the template is:</p><code class="block">1 #,
2 #,
3 #,
4 ,
5</code><a name="skip"></a><a name="id53"></a><h5>Skip</h5><p>The skip is the same as a continue, except that the delimiter in the loop will be skipped also.  The next example show the numbers 1 to 5. The number 1, 2, and 3 have the token # appended and are separated with a comma. As the example shows, the numbers higher than 3 will not execute the rest of the foreach anymore and the delimiter is not appended:</p><code class="block">{foreach 1..5 as $i}

{delimiter}
,
{/delimiter}

{$i}
{if $i &gt; 3} {skip} {/if}
#
{/foreach}</code><p>And outputs:</p><code class="block">1 #,
2 #,
3 #,
4
5</code><a name="break"></a><a name="id54"></a><h5>Break</h5><p>The break ends execution of the current foreach or while structure. The example below prints the numbers 1 and 2. Due to the break, the rest of the loop is skipped:</p><code class="block">{foreach 1..10 as $i}
{$i}
{if $i == 2} {break} {/if}
{/foreach}</code><a name="include"></a><a name="id55"></a><h5>Include</h5><p>The include calls other templates which will be executed within the current template. Variables can be passed on and retrieved from the included template. The generic template could then be used at multiple places and is configurable via the given variables.</p><p>The syntax of the include is as follows:</p><code class="block">{include &lt;template_name | location_object &gt;
 [ send &lt;send_variables&gt; ]
 [ receive &lt;receive_variables&gt; ]</code><p>The file that needs to be included is either specified with a string (template_name) or with a location object. The location object is explained in the section <a href="#template-locations">Template locations</a>.</p><p>The &lt;send_variables&gt; has this syntax:</p><code class="block">&lt;expression&gt; as &lt;variable&gt; | &lt;variable&gt;</code><p>And the &lt;receive_variables&gt; has almost the same syntax as the &lt;send_variables&gt;:</p><code class="block">&lt;variable&gt; as &lt;variable&gt; | &lt;variable&gt;</code><p>A next example will clarify the syntax a bit more:</p><code class="block">{include "calc_a_plus_b.ezt"
send     2 as $a,
         5 as $b
receive $c as $sum }</code><p>The included template calculates the sum of the given variables $a and $b, and returns the answer in variable $c. The expressions "2" and "5" are assigned to the variables $a and $b of the included template. The value of the (returned) variable $c is directly assigned to the variable $sum. The variable $sum does not need to be declared first.</p><p>The template "calc_a_plus_b.ezt" is:</p><code class="block">{use $a = false, $b = false}

{if $a === false || $b === false}
Variable $a or $b has an incorrect value.
{/if}

{return $a + $b as $c}</code><p>The next templates includes the "calc_a_plus_b.ezt" but does not use the expression part of the include:</p><code class="block">{var $a = 2, $b = 5}
{include "calc_a_plus_b.ezt"
send     $a, $b
receive $c }

{var $sum = $c}</code><a name="raw"></a><a name="id56"></a><h5>Raw</h5><p>The raw construct outputs raw information and is not affected by the <a href="#contexts">Contexts</a>.</p><p>For example, the XHTML context is set and an expression contains HTML characters (which should be sent to the output) then use the "raw" block:</p><code class="block">{var $myBoldText = "&lt;b&gt;Hello world&lt;/b&gt;"}
{raw $myBoldText}</code><p>This template outputs:</p><code class="block">&lt;b&gt;Hello world&lt;/b&gt;</code><a name="translation-constructs"></a><a name="id57"></a><h4>Translation Constructs</h4><p>Translation constructs allow you to embed translatable strings in your templates. Every construct requires at least a string and a context, the context can however be set by default to be valid for subsequent translatable string entries.</p><a name="tr-context"></a><a name="id58"></a><h5>tr_context</h5><p>Is used to set a default translation context. All <a href="#tr">tr</a> entries below this construct will then use this translation context if none is specified explicitly. Information on contexts can be found in the <a href="Translation_linguist-format.html#contexts">Qt Linguist format specification</a>.</p><p>This construct is used like:</p><code class="block">{tr_context "admin/forget_password"}</code><p>Each template can have multiple tr_context statements. The default context that is set with this construct is valid until the next one is encountered.</p><a name="tr"></a><a name="id59"></a><h5>tr</h5><p>The tr construct defines a translatable string, the simplest form of this construct is:</p><code class="block">{tr "String to translate"}</code><p>This will only work however, if there is a default context set with <a href="#tr-context">tr_context</a>. In case there is none set, you have to specify it yourself with the "context" parameter. The following two templates are equivalent:</p><code class="block">{tr_context "admin/forget_password"}
{tr "String to translate"}</code><p>and:</p><code class="block">{tr "String to translate" context "admin/forget_password"}</code><p>When a translator translates a text, it is sometimes useful to have slightly more information than just the context and the string itself. The tr construct therefore allows to add a comment to the translatable string with the "comment" parameter. This has no effect on how the tr construct is interpreted however. An example:</p><code class="block">{tr "Login" context "user/login" comment "Text before login input box"}</code><p>In many occasions, the translatable strings allow positional or named parameters to allow for changing the order of arguments. For example the English string "Search for 'appelmoes' returned 3 matches" can be translated in Dutch as: "Er zijn 3 items gevonden bij het zoeken naar 'appelmoes'". A simple concatenation mechanism of multiple translatable strings would no longer work. The tr construct supports parameterized strings in two different ways: with numerical replacement identifiers (such as %1 and %2) and with associative identifiers (such as %search_string and %matches). The following example illustrates how this is done in the simplest possible way:</p><code class="block">{tr "Search for '%1' returned '%2' matches" vars 'appelmoes', 3}</code><p>If no key is specified for variables, like in the above example, they are automatically given numbers, starting by 1. It is also possible to add specific positions to variables, like:</p><code class="block">{tr "Search for '%1' returned '%2' matches" vars 2 =&gt; 'appelmoes', 1 =&gt; 3}</code><p>This is perhaps not so useful for positional parameters like here, but it is necessary for named parameters as illustrated in the example here:</p><code class="block">{tr "Search for '%what' returned '%matchcount' matches" vars 'what' =&gt; 'appelmoes', 'matchcount' =&gt; 3}</code><p>It is of course also possible to mix those two cases:</p><code class="block">{tr "Search for '%1' returned '%matchcount' matches" vars 'matchcount' =&gt; 3, 'appelmoes'}</code><p>or:</p><code class="block">{tr "Search for '%1' returned '%matchcount' matches" vars 'appelmoes', 'matchcount' =&gt; 3}</code><p>Variables without any key, are always given positional identifiers in sequential order. When doing so, variables with a named key are ignored, while variables with a numerical key reset the next number in the auto-numbering sequence to the number of the key. The following example shows that:</p><code class="block">{tr "%1 %2 %3 %4 context "test" vars 3 =&gt; 'three', 'four', 1 =&gt; 'one', 'two'}</code><p>For information on how to setup translations for your templates, please refer to the section <a href="#translations">Translations</a>.</p><a name="extensions"></a><a name="id60"></a><h3>Extensions</h3><p>This section explains how you can extend your Template language. Extending the Template language gives you the opportunity to add more application specific functionality. Some examples of Template language extensions are:</p><ul><li><p>Adding a method to fetch information from a data structure. This data structure could be a single or a group of objects, a database, an array, etc.</p></li><li><p>Creating an HTML table using your own customized template blocks.</p></li><li><p>Doing an application specific calculation.</p></li></ul><p>Currently, there are two ways of adding custom functionality to the template. The methods are named: <strong>custom blocks</strong> and <strong>custom functions</strong>. Together we call them <strong>custom extensions</strong>.</p><p>First, we'll explain how to create a custom block. With the knowledge of these custom blocks, we explain - much shorter - the custom functions.</p><a name="custom-blocks"></a><a name="id61"></a><h4>Custom blocks</h4><p>Custom blocks are extra functionality that could be used inside the template language. These blocks are implemented in PHP. The next section explains how an custom block can be used. The sections thereafter discuss how to add a new custom block.</p><a name="custom-blocks-in-the-template-language"></a><a name="id62"></a><h5>Custom blocks in the Template language</h5><p>Custom blocks add specific behavior to the Template language. The most basic structure of a custom block - without any parameters - is:</p><code class="block">'{' &lt;name&gt; '}'</code><p>The block starts and ends with curly braces. The <em>&lt;name&gt;</em> identifies the custom block. Optionally, a custom block has also a closing block:</p><code class="block">'{' '/' &lt;name&gt; '}'</code><p>The name must be the same as the start block, but starts with a forward slash ('/'). The text between the open and close tag is considered as input data. Whether a custom block should have a close tag is up to the developer.</p><p>The next example demonstrates a custom block with an open and close tag that capitalizes the text in between:</p><code class="block">{capitalize}
    Guybrush Threepwood.
{/capitalize}</code><p>Another example that uses a custom block without a close tag:</p><code class="block">{capitalize "Guybrush Threepwood."}</code><p>Whether or not a custom block has a close tag, it handles the parameters the same. The structure of a custom block is as follows:</p><code class="block">'{' block_name [start_expression] [ &lt;param_name&gt; ['='] &lt;value&gt; ... ] '}'</code><p>Basically, it describes that a custom block can have:</p><ul><li><p>One optional expression which is not bound to a parameter name.</p></li><li><p>Zero or more named parameters with a value. Between the parameter name and value is an optional equal sign.</p></li></ul><p>Some example blocks that use parameters:</p><code class="block">{link "eZ systems" to "http://ez.no"}
{table border=true bgcolor="red"}
{debug}
{calculate 5 plus 5}
{join array( 'Hello', "world" ) with "_"}

{header style="bold"}
    Hello world
{/header}</code><p>Note that the values used in the examples are just ordinary expressions. Therefore it is possible to write:</p><code class="block">{link "eZ" . " systems" to 'http'. "://" . "ez.no"}
{calculate 2 + 3 plus 1 * 2 + 3}</code><p>Again, the optional and required parameters are up to the developer.</p><a name="adding-a-custom-block"></a><a name="id63"></a><h5>Adding a custom block</h5><p>New custom blocks are added to the Template engine with the <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateConfiguration.html#addExtension'>ezcTemplateConfiguration::addExtension</a>() method. This method expects the class name which implements the new custom block. The next example adds a custom block to the Template engine which is implemented in MyClass:</p><code class="block">$config = <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateConfiguration.html#getInstance'>ezcTemplateConfiguration::getInstance</a>();
$config-&gt;addExtension( "MyClass" );</code><p>The custom block class should implement the <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateCustomBlock.html'>ezcTemplateCustomBlock</a> interface. This interface has only one method getCustomBlockDefinition(). The class implementing this method should return an <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateCustomBlockDefinition.html'>ezcTemplateCustomBlockDefinition</a> object from a given block name, if possible.</p><a name="custom-block-definition"></a><a name="id64"></a><h5>Custom block definition</h5><p>The custom block definition describes how the Template engine should interpret the custom block. The information is provided by returning an instance of the <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateCustomBlockDefinition.html'>ezcTemplateCustomBlockDefinition</a>:</p><code class="block">class <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateCustomBlockDefinition.html'>ezcTemplateCustomBlockDefinition</a> extends <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateCustomExtension.html'>ezcTemplateCustomExtension</a>
{
    public $class;
    public $method;

    public $hasCloseTag;

    public $startExpressionName;
    public $optionalParameters = array();
    public $requiredParameters = array();

    public $isStatic;
}</code><p>The member variables that should be set in this class are:</p><p>The following custom block creates a hyper-link from a name and an URL:</p><code class="block">{link "name" to "url" [title "title"]}</code><p>This custom block has a:</p><ul><li><p>Required unnamed parameter that contains the name.</p></li><li><p>Required named parameter "to" that contains the URL.</p></li><li><p>Optional named parameter "title" that contains the title.</p></li></ul><p>Except for the class and the method name the CustomBlockDefinition should look like:</p><code class="block">$def = new <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateCustomBlockDefinition.html'>ezcTemplateCustomBlockDefinition</a>;

$def-&gt;class = "MyLink";
$def-&gt;method = "linkMethod";

$def-&gt;hasCloseTag = false;
$def-&gt;startExpressionName = "from";
$def-&gt;optionalParameters = array( "title" );
$def-&gt;requiredParameters = array( "from", "to" );</code><p>The CB definition should be made available to the Template engine via a class implementing the <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateCustomBlock.html'>ezcTemplateCustomBlock</a> interface:</p><code class="block">interface <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateCustomBlock.html'>ezcTemplateCustomBlock</a>
{
    public static function getCustomBlockDefinition( $name );
}</code><p>The class implementing the getCustomBlockDefinition() method should return an <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateCustomBlockDefinition.html'>ezcTemplateCustomBlockDefinition</a> for the given block name $name. The next code demonstrates a class that implements the interface:</p><code class="block">class MyLink implements <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateCustomBlock.html'>ezcTemplateCustomBlock</a>
{
    public static function getCustomBlockDefinition( $name )
    {
        switch ($name )
        {
            case "link":
                $def = new <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateCustomBlockDefinition.html'>ezcTemplateCustomBlockDefinition</a>;
                $def-&gt;class = "MyLink";
                //
                // Create definition
                //

                return $def;
        }

        return false;
    }
}</code><a name="implementing-the-custom-block"></a><a name="id65"></a><h5>Implementing the custom block</h5><p>In the CB definition is specified which class and what method should produce the custom block output. A typical implementation to create a hyper-link would be:</p><code class="block">public static function link( $parameters )
{
    $title = "";
    if( isset( $parameters["title"] ) )
    {
        $title = "title='". $parameters["title"] ."'";
    }

    return "&lt;a href='".$parameters["to"]."' $title&gt;".$parameters["from"]."&lt;/a&gt;"
}</code><p>The method implementing the custom block returns a string that will be inserted in the template output. The custom block parameters are provided in the first parameter as an array. The method itself must check whether the optional parameters are sent or not. Required parameters are always available as the template compiler throws a compiler exception if these parameters are absent.</p><p>The custom blocks that do have a close tag need a method that accepts two parameters. For example the following custom block has a close tag:</p><code class="block">{capitalize}
    Guybrush Threepwood
{/capitalize}</code><p>The method that implements the custom block:</p><code class="block">public static function capitalize( $parameters, $text )
{
    return strtoupper( $text );
}</code><p>The $parameters parameter is never used. The text between the open and close tag of the custom block is always passed in the second parameter.</p><a name="example"></a><a name="id66"></a><h5>Example</h5><p>The 'calc' custom block calculates the sum of the given values. The sum is calculated from the initial value plus or minus the values added to the "plus" and or "minus" parameter. Some usage examples are:</p><code class="block">{calc 5 plus 3}
{calc 5 plus array(2,5,2) minus 2}
{calc 2 minus 5}</code><p>The custom block could be implemented like:</p><code class="block">class CalcCustomBlock implements <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateCustomBlock.html'>ezcTemplateCustomBlock</a>
{
    public static function getCustomBlockDefinition( $name )
    {
        switch ($name )
        {
            case "calc":
                $def = new <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateCustomBlockDefinition.html'>ezcTemplateCustomBlockDefinition</a>;
                $def-&gt;class = __CLASS__;
                $def-&gt;method = "calculate";
                $def-&gt;hasCloseTag = false;
                $def-&gt;startExpressionName = "init";
                $def-&gt;requiredParameters = array("init");
                $def-&gt;optionalParameters = array("plus", "minus");
                return $def;
        }

        return false;
    }

    public static function calculate( $params )
    {
        $result = $params["init"];

        if ( isset( $params["plus"] ) )
        {
            if( is_array( $params["plus"] ) )
            {
                foreach( $params["plus"] as $value )
                {
                    $result += $value;
                }
            }
            else
            {
                $result += $params["plus"];
            }
        }

        if ( isset( $params["minus"] ) )
        {
            if( is_array( $params["minus"] ) )
            {
                foreach( $params["minus"] as $value )
                {
                    $result -= $value;
                }
            }
            else
            {
                $result -= $params["minus"];
            }
        }

        return $result;
    }
}</code><p>This new custom block needs to be assigned to the Template configuration:</p><code class="block">$config = <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateConfiguration.html#getInstance'>ezcTemplateConfiguration::getInstance</a>();
$config-&gt;addExtension( "CalcCustomBlock" );</code><p>And of course the template can be run like:</p><code class="block">$t = new <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplate.html'>ezcTemplate</a>();
$t-&gt;process( "my_template.ezt" );</code><a name="custom-functions"></a><a name="id67"></a><h4>Custom functions</h4><p>This section explains how the custom function can be implemented. Custom blocks and custom functions are very similar.</p><a name="custom-functions-in-the-template-language"></a><a name="id68"></a><h5>Custom functions in the Template language</h5><p>Custom functions are extra functions that can be used in the Template expressions. Some examples are:</p><code class="block">Greatest common divisor: {gcd(8, 12)}
{sin( $angle ) * 2}
{matrix_multiply( $m1, $m2)}
{fetch_from_database("items", 2)}</code><p>Basically, the second line in the example runs a custom function and multiplies the result with two. This demonstrates that the difference between a custom block and a custom function. Custom functions can be used within an expression. Custom blocks are directly generating an output result.</p><a name="adding-a-new-custom-function"></a><a name="id69"></a><h5>Adding a new custom function</h5><p>As with the custom block, custom functions are added to the Template engine by the <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateConfiguration.html#addExtension'>ezcTemplateConfiguration::addExtension</a>() method. The class name given to this method should implement the <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateCustomFunction.html'>ezcTemplateCustomFunction</a> interface. Notice that this is the same as adding a custom block.</p><code class="block">$config = <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateConfiguration.html#getInstance'>ezcTemplateConfiguration::getInstance</a>();
$config-&gt;addExtension( "MyClass" );</code><p>The example above adds <em>MyClass</em> to the <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateConfiguration.html'>ezcTemplateConfiguration</a>. MyClass implements the getCustomFunctionDefinition() from the <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateCustomFunction.html'>ezcTemplateCustomFunction</a> interface. This function returns an <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateCustomFunctionDefinition.html'>ezcTemplateCustomFunctionDefinition</a> object:</p><code class="block">class <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateCustomFunctionDefinition.html'>ezcTemplateCustomFunctionDefinition</a> extends <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateCustomExtension.html'>ezcTemplateCustomExtension</a>
{
    public $class;
    public $method;
    public $sendTemplateObject = false;

    // Deprecated:
    // public $parameters = array();
}</code><p>The $class and $method parameter are the same as for custom blocks. The $parameters variable is obsolete with version 1.2. It used to specify the required and optional parameters for the custom function.</p><ul><li><p>Required parameters are named strings.</p></li><li><p>Optional parameters are named strings enclosed with square brackets. These parameters should be specified after the required parameters.</p></li></ul><p>In version 1.2 and up it uses reflection to find the required and optional parameters. Due some bugs in the reflection classes it works properly in PHP version 5.2 and up.</p><p>It is also possible to accept a variable number of (extra) arguments. For this you need to set the <em>variableArgumentList</em> property of the <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateCustomFunctionDefinition.html'>ezcTemplateCustomFunctionDefinition</a>.</p><p>The variable <em>$sendTemplateObject</em> adds the possibility to send the current template object to the custom function.</p><p>As with functions in PHP the order of the unnamed parameters matter. The next example demonstrates a complete custom function implementation:</p><code class="block">class MyClass implements <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateCustomFunction.html'>ezcTemplateCustomFunction</a>
{
    public static function getCustomFunctionDefinition( $name )
    {
        switch ($name )
        {
            case "func":
                $def = new <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateCustomFunctionDefinition.html'>ezcTemplateCustomFunctionDefinition</a>();
                $def-&gt;class = "MyClass";
                $def-&gt;method = "customFunction";

                // Deprecated:
                // $def-&gt;parameters = array( "firstParam", "secondParam", "[thirdParam]");

                return $def;
        }

        return false;
    }


    public static function customFunction( $firstParam, $secondParam, $thirdParam = "isOptional" )
    {
        // Implementation.

        return "string";
    }
}</code><p>The custom parameters specified in the definition block should also be present in the <em>customFunction</em> implementation. Three parameters are specified, so the customFunction implementation should have three parameters.  The last parameter in the parameter definition is specified as optional, so should the last parameter in customFunction be optional.</p><p>The interface of the <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateCustomFunction.html'>ezcTemplateCustomFunction</a> requires to implement the getCustomFunctionDefinition() method:</p><code class="block">interface <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateCustomFunction.html'>ezcTemplateCustomFunction</a>
{
    public static function getCustomFunctionDefinition( $name );
}</code><a name="named-parameters"></a><a name="id70"></a><h5>Named parameters</h5><p>New in version 1.2 of the Template engine are named parameters. The advantage of named parameters is that the order of the parameters are no longer important and that parameters can be omitted that otherwise was not possible.  The next example shows a common custom function retrieving items from the database:</p><code class="block">// fetch_item ( select = "*", start = 0, limit = false, orderBy = "id", reverseOrder = false )
{ fetch_item("*", 0, false, "name") } // Fetch everything but order by 'name'</code><p>This example fetches everything from the items table and sorts it on "name". Without named parameters the problem is that only the second last parameter needs to be changed and therefore all the previous parameters need to be given.</p><p>Named parameters are written in the form <em>"keyword = value"</em>. The keyword is the name of the parameter. The equal sign is used as separator because it is not possible to do any assignments within expressions.</p><p>Using named parameters the code from the previous example is reduced to:</p><code class="block">// fetch_item ( select = "*", start = 0, limit = false, orderBy = "id", reverseOrder = false )
{ fetch_item( orderBy = "name") } // Fetch everything but order by 'name'</code><p>Besides that the code is shorter, it is also more descriptive.</p><a name="sending-template-objects"></a><a name="id71"></a><h5>Sending template objects</h5><p>In a few cases the template object is needed in the custom function implementation. With access to the template object, the configuration and other template settings could be retrieved and used.</p><p>If the variable <em>sendTemplateObject</em> is set to <em>true</em>, the first parameter in the function contains the template object. The following</p><p>The next example adds the custom function <em>templatePath</em>:</p><code class="block">class MyClass implements <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateCustomFunction.html'>ezcTemplateCustomFunction</a>
{
    public static function getCustomFunctionDefinition( $name )
    {
        switch ($name )
        {
            case "templatePath":
                $def = new <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateCustomFunctionDefinition.html'>ezcTemplateCustomFunctionDefinition</a>;
                $def-&gt;class = "MyClass";
                $def-&gt;method = "templatePath";
                $def-&gt;sendTemplateObject = true;

                return $def;
        }

        return false;
    }


    public static function templatePath( $templateObj )
    {
        return $templateObj-&gt;configuration-&gt;templatePath;
    }
}</code><a name="caching"></a><a name="id72"></a><h3>Caching</h3><p>The purpose of the template cache is to speed up the processing time of a template by storing its output to a file. This file is known as the <em>cache file</em>. When the same template is requested later on, the cached contents are displayed without processing the template first. The time consuming instructions, like computations and requests to a database, can then be reduced or omitted.</p><p>Caching can truly reduce the processing time of the templates, but caching needs to be handled with care. The developer needs to:</p><ul><li><p>Add caching at the correct, time consuming, spots in the template.</p></li><li><p>Make sure that the cache is expired and renewed in time.</p></li><li><p>Clean up the unused cache files.</p></li></ul><p>Each cached template has a bit of overhead in comparison with an uncached template. The extra work is to check if the cache file exists and if it's valid, optionally regenerate the cache, and execute the cache. If the cache file needs to be regenerated too often, the template is probably processed quicker without caching at all. The same applies for small, non-time consuming templates.</p><p>Another issue the developer should keep in mind is that the cache needs to be expired and renewed in time. Usually a template cache is valid for a limited time. This can be a timeout (e.g. after 2 hours) or a trigger (an object changes) that expires the cache. The triggers and timeouts need to be available in the template.</p><p>The last issue is that unused cache files need to be discarded. Without a proper cache clean up mechanism the system will eventually flood with unused cache files. It is the developer's responsibility to remove those files.</p><a name="configuration"></a><a name="id73"></a><h4>Configuration</h4><p>The template cache is enabled by default and activated when cache blocks are present in the templates. The template configuration, <em>ezcTemplateConfiguration</em> controls the locations where the cache files are stored and the mechanism that cleans up the unused cache files. The configuration has the following properties relevant to caching:</p><ul><li><p><em>cachedTemplatesPath</em>: The location where the cached templates should be stored. The <em>compiledPath</em> and the <em>cachedTemplatePath</em> properties together form the complete cache path.</p></li><li><p><em>cacheManager</em>: This property is assigned to a cache manager object that keeps track of the generated cache files and is responsible for its clean up.</p></li><li><p><em>disableCache</em>: Disables all caching, useful during development.</p></li></ul><p>The next code demonstrates an example configuration:</p><code class="block">$config = <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateConfiguration.html#getInstance'>ezcTemplateConfiguration::getInstance</a>();
$config-&gt;templatePath = '/mydir/templates/';
$config-&gt;compilePath = '/mydir/templates_bin/';
$config-&gt;cachedTemplatesPath = "CACHE";
$config-&gt;disableCache = false;

$config-&gt;cacheManager = new DatabaseCacheManager();

$template = new <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplate.html'>ezcTemplate</a>();
$template-&gt;process( "hello_world.ezt" );</code><p>The engine will process the following template:</p><code class="block">"/mydir/templates/hello_world.ezt"</code><p>The compiled template and the cached template will then be stored in:</p><code class="block">"/mydir/templates_bin/compiled_templates/"
"/mydir/templates_bin/CACHE/"</code><p>The 'compiled_templates' is a default setting. The cache manager that will be used is the <em>DatabaseCacheManager</em>. Details about the cache manager are explained later.</p><a name="cache-tags"></a><a name="id74"></a><h4>Cache tags</h4><p>There are two methods to enable caching: <em>cache_block</em> and <em>cache_template</em>. The <em>cache_block</em> enables caching between the open and close tag:</p><code class="block">{"dynamic"}

{cache_block}
    {foreach 1..10 as $i}
        {$i}
    {/foreach}
{/cache_block}

{"dynamic"}</code><p>This example caches the <em>foreach</em>-loop. The strings that contains <em>"dynamic"</em> are outside the cache block; thus not cached.</p><p>The <em>cache_template</em> starts caching after this tag until the end of the template. In the next example everything is cached except the string that contains <em>"dynamic"</em>:</p><code class="block">{"dynamic"}

{cache_template}

{foreach 1..10 as $i}
    {$i}
{/foreach}

{"cached"}</code><p>Sometimes a large block needs to be cached with the exception of a small block of template code. Take for instance a relatively static page with the current time in one corner. The <em>dynamic</em> block is a block that can only be used inside a <em>cache_block</em> or after the <em>cache_template</em>. The code inside the <em>dynamic</em> block is not cached and will always be executed. The next example uses the <em>dynamic</em> block to display the current time:</p><code class="block">{cache_template}

The current time is:

{dynamic}
    {date_format_timestamp("H:i:s")}
{/dynamic}</code><p>Note that the example above is only for demonstration purposes. The template is so simple that it is probably quicker to use no caching at all.</p><a name="cache-renewal"></a><a name="id75"></a><h4>Cache renewal</h4><p>Usually cached templates are valid for a limited time. A certain page is known to be valid for some hours or until a value changes in the database. The Template engine supports three mechanisms to expire the cache: <em>cache-keys</em>, <em>time-to-live</em> (TTL), and a <em>cache manager</em>.</p><p>The cache-keys and TTL are both parameters of the cache syntax. These parameters check whether the cache is still valid and if needed create a new version.</p><p>The cache manager needs to be programmed manually. It gives a better control over the cache and can also remove old cache files.</p><a name="cache-keys"></a><a name="id76"></a><h5>Cache keys</h5><p>Both <em>cache_block</em> and <em>cache_template</em>  have a <em>keys</em> parameter. This parameter can be used to define the uniqueness of a cache block. For every combination of different values of the parameter, a separate file is stored on the disk, containing the output of the cache block. The <em>keys</em> parameter can be an expression but is usually limited to a variable or function call. The next example creates new cache files when the user ID changes:</p><code class="block">{use $user_id}
{cache_block keys $user_id}
    Show user information.
{/cache_block}

{cache_block keys getUserId()}
    Show user information, again.
{/cache_block}</code><p>The first cache_block relies on the imported <em>$user_id</em>. The second <em>cache_block</em> uses a custom function that returns the ID.</p><p>The given cache key can be of any type. If the type is a scalar (boolean, integer, float, or string) then the value is compared as a string. For arrays, it's compared with the checksum of the dumped structure. For objects, the comparison consists of two steps. First will be checked if the object has the <em>cacheKey</em> method. If this method exists on the object then this value will be used. Otherwise the checksum of the object dump will be used.</p><p>The example below uses an user object as cache key. The name property of this object will be shown:</p><code class="block">{use $userObj}
{cache_template keys $userObj}

{$userObj-&gt;name}</code><p>The user object can be implemented like:</p><code class="block">class User
{
    public $firstName;
    public $lastName;
    public $name;
    public $id;

    public function cacheKey()
    {
        return $this-&gt;id;
    }

    public function __construct( $firstName, $lastName, $id = 1 )
    {
        $this-&gt;firstName = $firstName;
        $this-&gt;lastName = $lastName;
        $this-&gt;name = $firstName . " " . $lastName;
        $this-&gt;id = $id;
    }
}</code><p>And the application calling the template is done like this:</p><code class="block">$t = new <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplate.html'>ezcTemplate</a>();
$t-&gt;send-&gt;userObj = new User( "Bernard", "Black" );
echo $t-&gt;process( "my_template.ezt" );</code><a name="time-to-live"></a><a name="id77"></a><h5>Time-to-live</h5><p>The <em>ttl</em> parameter makes it possible to specify how long a cache block should live in number of seconds. The cache is removed after the timeout. Note that this behavior is slightly different than the <em>cache-key</em>. The <em>cache-key</em> creates a new version of the cache but does not remove any cache files.</p><p>The next example creates a cache block that is valid for two hours:</p><code class="block">{cache_block ttl 2*60*60}
    News that changes not too often.
{/cache_block}</code><p>Via a custom function the TTL can be used to renew the cache at certain predefined timestamps:</p><code class="block">{cache_block ttl getRemainingTime(minute=0, hour=6)}
    Updated each morning at 6 o'clock
{/cache_block}</code><p>The custom function <em>getRemainingTime</em> calculates the remaining seconds until it is 6 o'clock in the morning.</p><a name="cache-manager"></a><a name="id78"></a><h4>Cache manager</h4><p>In the previous sections it's already hinted about the cache manager. The cache manager is a slightly complex but powerful mechanism to control the cached pages. The cache manager is an interface that needs to be implemented and assigned to the Template engine. The implementation gives the application the possibilities to:</p><ul><li><p>Mark expired cache files based on application criteria.</p></li><li><p>Remove old cache files.</p></li><li><p>Keep track of the cache dependencies.</p></li></ul><p>The solutions above need to be implemented from the cache manager interface. This implementation allows the developer to make an application-dependent solution.</p><a name="the-cache-manager-interface"></a><a name="id79"></a><h5>The cache manager interface</h5><p>The user application and the Template engine communicate via method calls on the cache manager implementation. The cache manager interface has the following methods:</p><code class="block">interface <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateCacheManager.html'>ezcTemplateCacheManager</a>
{
    public function startCaching( $template, $templatePath, $cachePath, $cacheKeys );
    public function stopCaching();
    public function isValid( $template, $templateName, $cacheName );
    public function register( $name, $value );
    public function update( $name, $value );
    public function includeTemplate( $template, $templatePath );
    public function cleanExpired();
}</code><p>The Template engine calls the following methods on the interface. Usually those methods are not called from the user application.</p><ul><li><p><em>startCaching</em>: When a cache file is going to be created.</p></li><li><p><em>stopCaching</em>: After the cache file is created.</p></li><li><p><em>isValid</em>: To check whether the given cache file is still valid.</p></li><li><p><em>includeTemplate</em>: Notify the cache manager that a sub template is included.</p></li></ul><p>The remaining methods from the interface are called from the user application:</p><ul><li><p><em>register</em>: Register a value that is related to the cache file currently created.</p></li><li><p><em>update</em>: A registered value is updated. This <strong>may</strong> indicate that a cache file is outdated.</p></li><li><p><em>cleanExpired</em>: Removes the expired cache files.</p></li></ul><p>Typically the cache creation procedure is as follows. This procedure gives insight how the cache manager can be used:</p><ol><li><p>The user application calls the method: <em>$t-&gt;process("my_template.ezt")</em>.</p></li><li><p>The template <em>"my_template.ezt"</em> caches parts of the page.</p></li><li><p>If a cache file exists for the requested template, the Template component calls <em>CacheManager::isValid()</em> to see whether the cache file is still correct. If it is then the cache contents can be returned. Otherwise a new cache file will be created and returned.</p></li><li><p>When a cache file is going to be created, the <em>CacheManager::startCaching()</em> method is called. The Cache Manager is now informed that all following function calls in the application are used inside the cache.</p></li><li><p>Application code returning data which may be modified in the future should be registered to the cache manager. This is done via the <em>CacheManager::register()</em> method.</p></li><li><p>The <em>CacheManager::includeTemplate()</em> is called when another template is included.</p></li><li><p>The <em>CacheManager::stopCaching()</em> is called when the cache file is created.</p></li><li><p>The user application should call the <em>CacheManager::update()</em> method when a change in the database or application may affect any of the caches.</p></li></ol><p>Keeping track of the values used in the caches is probably best stored in a database. Using the file system is also possible but makes things more complicated.</p><a name="database-storage"></a><a name="id80"></a><h5>Database storage</h5><p>The database is a good medium to keep track of all the generated caches. It can quickly mark lots of cache files as expired. The real removal of the cache files from the file system can then be done when the server load is low.</p><p>In which database tables the cache information is stored depends on the implementation of the cache manager. In our example we will use two tables: <em>cache_files</em> and <em>cache_values</em>.  The table <em>cache_files</em> has at least the following fields:</p><table><thead><tr><th><p class="cell">Field</p></th><th><p class="cell">Type</p></th><th><p class="cell">Null</p></th><th><p class="cell">Key</p></th><th><p class="cell">Default</p></th><th><p class="cell">Extra</p></th></tr></thead><tbody><tr><td><p class="cell">id</p></td><td><p class="cell">int(10) unsigned</p></td><td><p class="cell">NO</p></td><td><p class="cell">PRI</p></td><td><p class="cell">NULL</p></td><td><p class="cell">auto_increment</p></td></tr><tr><td><p class="cell">cache</p></td><td><p class="cell">varchar(255)</p></td><td><p class="cell">NO</p></td><td><p class="cell">MUL</p></td><td/><td/></tr><tr><td><p class="cell">expired</p></td><td><p class="cell">tinyint(4)</p></td><td><p class="cell">NO</p></td><td/><td><p class="cell">0</p></td><td/></tr></tbody></table><p>The fields store:</p><p>The table <em>cache_values</em> has the following fields:</p><table><thead><tr><th><p class="cell"><strong>Field</strong></p></th><th><p class="cell">Type</p></th><th><p class="cell">Null</p></th><th><p class="cell">Key</p></th><th><p class="cell">Default</p></th><th><p class="cell">Extra</p></th></tr></thead><tbody><tr><td><p class="cell">cache_id</p></td><td><p class="cell">int(10) unsigned</p></td><td><p class="cell">NO</p></td><td><p class="cell">PRI</p></td><td/><td/></tr><tr><td><p class="cell">name</p></td><td><p class="cell">varchar(50)</p></td><td><p class="cell">NO</p></td><td><p class="cell">PRI</p></td><td/><td/></tr><tr><td><p class="cell">value</p></td><td><p class="cell">varchar(255)</p></td><td><p class="cell">NO</p></td><td><p class="cell">PRI</p></td><td/><td/></tr></tbody></table><p>The fields store:</p><p>Another table can also store the cache keys that belong to the cache. The structure of this table is similar to the table <em>cache_values</em>.</p><a name="database-fetch"></a><a name="id81"></a><h5>Database fetch</h5><p>Often a database result needs to be shown in a template. Two techniques are commonly used:</p><ul><li><p>Do the database queries inside the application. Send the result to the template.</p></li><li><p>Implement a custom function or block that can retrieve database information inside the template.</p></li></ul><p>The first solution has arguably a better separation between application and layout code. The second solution has the main advantage that it is easier to optimize. In this section we will continue with the second form.</p><p>The following template code shows the user information of a single user. The template uses a custom function <em>db_fetch</em> that retrieves the user information as an object:</p><code class="block">{use $userID}
{cache_template keys $userID}
{var $userObj = db_fetch(object="user", id=$userID)}

Name: {$userObj-&gt;name} &lt;br/&gt;
Name: {$userObj-&gt;address} &lt;br/&gt;
Email:{$userObj-&gt;email}&lt;br/&gt;</code><p>The caching system creates a separate cache file for each <em>userID</em>. This cache file is valid, until information changes. If <em>userID</em> 1 changes its e-mail address, the Template engine will still use the old cache file. The solution for this problem is that the application informs the Template engine via the Cache Manager about this information update.</p><p>When the template is run for the first time, it calls the following methods in order:</p><ol><li><p><em>startCaching( $template, $templatePath, $cachePath, $cacheKeys )</em>. The current template will be cached. The $cachePath should be stored in the <em>cache_files</em> database. The following code could be an implementation of the <em>startCaching</em> method:</p><code class="block">public function startCaching( $template, $templatePath, $cachePath, $cacheKeys )
{
    // Get the current database handler.
    $db = <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcDbInstance.html#get'>ezcDbInstance::get</a>();

    // Get the current cache ID, if it does exist.
    $q = $db-&gt;prepare( "SELECT id FROM cache_files WHERE cache = :cache" );
    $q-&gt;bindValue( ":cache", $cachePath );
    $q-&gt;execute();

    // One result and make sure the query is terminated.
    $r = $q-&gt;fetchAll();

    if ( sizeof( $r ) &gt; 0 ) // Do we have any results?
    {
        $id = $r[0]["id"];

        // Renew the cache_file.
        $s = $db-&gt;prepare( "UPDATE cache_files SET expired=0 WHERE id = :id" );
        $s-&gt;bindValue( ":id", $id );
        $s-&gt;execute();
    }
    else
    {
        // Insert the new cache file
        $q = $db-&gt;prepare( "INSERT INTO cache_files VALUES( '', :cache, '', 0)" );
        $q-&gt;bindValue( ":cache", $cachePath );
        $q-&gt;execute();
        $id = $db-&gt;lastInsertId();
    }

    // Mark that the template is currently creating a cache.
    $this-&gt;isCaching = true;
    $this-&gt;template_id = $id;
}</code></li></ol><p>The code checks whether the cache file is already registered. If the cache file is available then it sets the <em>expired</em> status to 0. Otherwise it adds the cache to the table, with a new id and <em>expired</em> set to 0.</p><p>The <em>cache_files</em> table contains something like:</p><table><thead><tr><th><p class="cell">id</p></th><th><p class="cell">cache</p></th><th><p class="cell">expired</p></th></tr></thead><tbody><tr><td><p class="cell">01</p></td><td><p class="cell">compiles/cache/user.ezt-9dsafa0</p></td><td><p class="cell">0</p></td></tr><tr><td><p class="cell">02</p></td><td><p class="cell">compiles/cache/user.ezt-84fdvj2</p></td><td><p class="cell">0</p></td></tr></tbody></table><ol><li><p><em>register( $name, $value )</em>. This function is called by the user application <strong>during</strong> cache creation. In our example the fetch function which returns the user object should call the <em>register</em> function.</p><code class="block">public static function fetch( $object, $id )
{
    $db = <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcDbInstance.html#get'>ezcDbInstance::get</a>();
    $s = $db-&gt;createSelectQuery();
    $s-&gt;select( "*" )-&gt;from( $object )-&gt;where( $s-&gt;expr-&gt;eq( "id", $id ) );

    $statement = $s-&gt;prepare();
    $statement-&gt;execute();

    $result = $statement-&gt;fetchAll();

    // Inform the cache manager
    <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateConfiguration.html#getInstance'>ezcTemplateConfiguration::getInstance</a>()-&gt;cacheManager-&gt;register( $object, $result[0]["id"] );
}</code></li></ol><p>An example implementation of the <em>register</em> method is as follows:</p><code class="block">public function register( $name, $value )
{
    if ( $this-&gt;isCaching )
    {
        $db = <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcDbInstance.html#get'>ezcDbInstance::get</a>();
        $s = $db-&gt;prepare( "REPLACE INTO cache_values VALUES ( :id, :name, :value )" );
        $s-&gt;bindValue( ":id", $this-&gt;template_id );
        $s-&gt;bindValue( ":name", $name );
        $s-&gt;bindValue( ":value", $value );
        $s-&gt;execute();
    }
}</code><p>After registration the <em>cache_values</em> table contains something like:</p><table><thead><tr><th><p class="cell">id</p></th><th><p class="cell">name</p></th><th><p class="cell">value</p></th></tr></thead><tbody><tr><td><p class="cell">01</p></td><td><p class="cell">user</p></td><td><p class="cell">1</p></td></tr><tr><td><p class="cell">02</p></td><td><p class="cell">user</p></td><td><p class="cell">2</p></td></tr></tbody></table><p>Via the <em>cache_files</em> table, we know that the user ID 1 is bound to the cache file 'compiles/cache/user.ezt-9dsafa0' and it is not expired.</p><ol><li><p><em>stopCaching()</em>. The method is called when the caching is done. The only thing that needs to be done, is to set <em>isCaching</em> to <em>false</em>.</p><code class="block">public function stopCaching()
{
    $this-&gt;isCaching = false;
}</code></li></ol><p>Right now, the cache file is created. The database contains the user IDs requested during the cache creation. Since the cache file is available, the Template engine will also call the <em>isValid()</em> method on the next request. If this method returns <em>true</em> then the values used in the cache are unaltered. Let's continue with the example and assume that the user application does change the data of one user.</p><ol><li><p><em>update( $name, $value )</em>. The user application calls this method when a value changes that is possibly used inside the templates. The snippet below modifies the user name.</p><code class="block">public static function updateUser( $id )
{
    $db = <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcDbInstance.html#get'>ezcDbInstance::get</a>();
    $q = $db-&gt;createUpdateQuery();

    $q-&gt;update( "user" )-&gt;set( "email", $q-&gt;bindValue( "bernard@example.com" ) )-&gt;where( $q-&gt;expr-&gt;eq( 'id', $id ) );
    $st = $q-&gt;prepare();
    $st-&gt;execute();

    // Update the users.
    <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateConfiguration.html#getInstance'>ezcTemplateConfiguration::getInstance</a>()-&gt;cacheManager-&gt;update( "user", $id );
}</code></li></ol><p>Most important is the last line which updates the user with the ID $id. The <em>CacheManager::update</em> method can be implemented like:</p><code class="block">public function update( $name, $value )
{
    $db = <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcDbInstance.html#get'>ezcDbInstance::get</a>();

    $qry = "UPDATE cache_files, cache_values SET cache_files.expired=1 ".
           "WHERE cache_files.id = cache_values.cache_id AND
           cache_values.name = :name AND cache_values.value = :value";

    $s = $db-&gt;prepare( $qry );
    $s-&gt;bindValue( ":name", $name );
    $s-&gt;bindValue( ":value", $value );
    $s-&gt;execute();
}</code><p>This method expires all the cache files that have the matching cache values: $name and $value. If we assume that user with ID 1 changes the e-mail address, the <em>cache_files</em> table is:</p><table><thead><tr><th><p class="cell">id</p></th><th><p class="cell">cache</p></th><th><p class="cell">expired</p></th></tr></thead><tbody><tr><td><p class="cell">01</p></td><td><p class="cell">compiles/cache/user.ezt-9dsafa0</p></td><td><p class="cell">1</p></td></tr><tr><td><p class="cell">02</p></td><td><p class="cell">compiles/cache/user.ezt-84fdvj2</p></td><td><p class="cell">0</p></td></tr></tbody></table><p>And the <em>cache_values</em> table remains the same:</p><table><thead><tr><th><p class="cell">id</p></th><th><p class="cell">name</p></th><th><p class="cell">value</p></th></tr></thead><tbody><tr><td><p class="cell">01</p></td><td><p class="cell">user</p></td><td><p class="cell">1</p></td></tr><tr><td><p class="cell">02</p></td><td><p class="cell">user</p></td><td><p class="cell">2</p></td></tr></tbody></table><ol><li><p><em>isValid( $template, $templateName, $cacheName )</em>. The Template engine calls this method to check whether the cache is still valid. See an example implementation below:</p><code class="block">public function isValid( $template, $templateName, $cacheName )
{
    $db = <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcDbInstance.html#get'>ezcDbInstance::get</a>();

    // Check whether the cache is registered and if it's expired.
    $q = $db-&gt;prepare( "SELECT id, expired FROM cache_files WHERE cache = :cache" );
    $q-&gt;bindValue( ":cache", $cacheName );
    $q-&gt;execute();

    $r = $q-&gt;fetchAll(); // Expect 0 or 1 result

    if ( count( $r ) == 0 || $r[0]["expired"] == 1 )
    {
        return false;
    }

    return true;
}</code></li></ol><p>When the cache file does not exist or when the cache file is marked as <em>expired</em> the function returns <em>false</em>, otherwise <em>true</em>. The Template engine regenerates the cache if this method returns <em>false</em>. Otherwise the cache is displayed.</p><p>In this section we have discussed how to expire the cache when values in the database change. The implementation of the cache manager is limited to this problem for now. The following sections explain other problems that can be solved using the cache manager.</p><a name="loose-coupling"></a><a name="id82"></a><h5>Loose coupling</h5><p>In the previous section we explained that the cache manager should be informed when data used in the templates is requested or altered. This requirement enforces strong dependencies, everywhere in the application code are function calls to the cache manager.</p><p>The previous section uses the following two example functions inside the user application to update the cache manager:</p><code class="block">public static function fetch( $object, $id )
{
    $db = <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcDbInstance.html#get'>ezcDbInstance::get</a>();
    $s = $db-&gt;createSelectQuery();
    $s-&gt;select( "*" )-&gt;from( $object )-&gt;where( $s-&gt;expr-&gt;eq( "id", $id ) );

    $statement = $s-&gt;prepare();
    $statement-&gt;execute();

    $result = $statement-&gt;fetchAll();

    // Inform the cache manager
    <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateConfiguration.html#getInstance'>ezcTemplateConfiguration::getInstance</a>()-&gt;cacheManager-&gt;register( $object, $result[0]["id"] );
}

public static function updateUser( $id )
{
    $db = <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcDbInstance.html#get'>ezcDbInstance::get</a>();
    $q = $db-&gt;createUpdateQuery();

    $q-&gt;update( "user" )-&gt;set( "email", $q-&gt;bindValue( "bernard@example.com" ) )-&gt;where( $q-&gt;expr-&gt;eq( 'id', $id ) );
    $st = $q-&gt;prepare();
    $st-&gt;execute();

    // Update the users.
    <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateConfiguration.html#getInstance'>ezcTemplateConfiguration::getInstance</a>()-&gt;cacheManager-&gt;update( "user", $id );
}</code><p>The call to the <em>register</em> and <em>update</em> methods are making dependencies with the cache manager. These method calls can be replaced with a signal from the SignalSlot component. See the following example code:</p><code class="block">public static function fetch( $object, $id )
{
    $db = <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcDbInstance.html#get'>ezcDbInstance::get</a>();
    // ...
    $result = $statement-&gt;fetchAll();

    if( $object == "user")
    {
        User::signals()-&gt;emit( "fetched", "user", $results[0]["id"] );
    }
}

public static function updateUser( $id )
{
    $db = <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcDbInstance.html#get'>ezcDbInstance::get</a>();
    // ...
    $st-&gt;execute();

    User::signals()-&gt;emit( "updated", "user", $id );
}</code><p>The emitted signal describes what just has happened. E.g. There is a user updated with ID number $id. This signal can be used not only for the cache manager but also for e.g. logging.</p><p>The <em>User::signals()</em> method returns an <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcSignalCollection.html'>ezcSignalCollection</a> that belongs to the User objects. A signal is sent everytime a user is read or changed. The <em>signals</em> method can be implemented as follows:</p><code class="block">public static function signals()
{
    if( self::$signals == null )
    {
        self::$signals = new <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcSignalCollection.html'>ezcSignalCollection</a>( __CLASS__ );
    }

    return self::$signals;
}</code><p>The next step is to connect the signals to the cache manager. The connection should be done at a place before the Template is processed. For example in the <em>index.php</em> file. Creating the connections can be done like:</p><code class="block">$tc = <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateConfiguration.html#getInstance'>ezcTemplateConfiguration::getInstance</a>();
User::signals()-&gt;connect( "fetched", array( $tc-&gt;cacheManager, "register" ) );
User::signals()-&gt;connect( "updated", array( $tc-&gt;cacheManager, "update" ) );</code><p>The signal <em>fetched</em> from the <em>User</em> object is connected to the <em>register</em> method from the cache manager. And the <em>update</em> signal is connected to the <em>update</em> method from the cache manager.</p><a name="including-templates"></a><a name="id83"></a><h5>Including templates</h5><p>Assume there are two templates: A and B. Template A is cached and includes template B. Below is the code of template A:</p><code class="block">{cache_template}
{include "B"}</code><p>Template B prints only:</p><code class="block">Hello world</code><p>After template A is executed a cache file is created. This cache file contains the same data as template B. Everything will work fine, until the developer changes template B.</p><p>Template B is altered to:</p><code class="block">Goodbye world</code><p>Template A uses the cache and therefore the modification of template B is not checked. Template A will still print "Hello world".</p><p>The cache manager can solve the issue described above with the cost of some overhead.</p><p>The cache manager implemented in the section <a href="#database-fetch">Database fetch</a> should be modified at three points:</p><ol><li><p>The method <em>includeTemplate</em> should be implemented. The <em>includeTemplate</em> is called everytime a cached template includes another template. The following code stores the include template in the <em>cache_values</em> table.</p><code class="block">public function includeTemplate( $template, $templatePath )
{
    if ( $this-&gt;depth &gt;= 0 )
    {
        $db = <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcDbInstance.html#get'>ezcDbInstance::get</a>();
        $id = $this-&gt;keys[$this-&gt;depth]["cache_id"];

        $q = $db-&gt;prepare( "REPLACE INTO cache_values VALUES(:id, :name, :value)" );
        $q-&gt;bindValue( ":id", $id );
        $q-&gt;bindValue( ":name", "include" );
        $q-&gt;bindValue( ":value", $templatePath );
        $q-&gt;execute();
    }
}</code></li><li><p>The <em>startCaching</em> method should also store the template currently processed. The following code should be added in the body of the 'else' statement:</p><code class="block">$q = $db-&gt;prepare( "REPLACE INTO cache_values VALUES(:id, :name, :value)" );
$q-&gt;bindValue( ":id", $id );
$q-&gt;bindValue( ":name", "include" );
$q-&gt;bindValue( ":value", $templatePath );
$q-&gt;execute();</code></li></ol><p>The current template includes 'itself'. This makes it easier to expire the cache.</p><ol><li><p>The <em>isValid</em> method should be extended that it also checks all the modification times of the included cache files:</p><code class="block">$q = $db-&gt;prepare( "SELECT * FROM cache_values WHERE name = 'include' AND cache_id = :id" );
$q-&gt;bindValue( ":id", $r[0]["id"] );
$q-&gt;execute();

$r = $q-&gt;fetchAll();
foreach ( $r as $a )
{
    if ( filemtime( $a["value"] ) &gt; filemtime( $cacheName ) )
    {
        return false;
    }
}
return true;</code></li></ol><p>The code retrieves all the included cache files and checks if an included cache file is newer than the requested cache file.</p><p>The complete code of the include mechanism is documented in the cache manager interface.</p><a name="translations"></a><a name="id84"></a><h3>Translations</h3><p>With the <a href="#tr-context">tr_context</a> and <a href="#tr">tr</a> template constructs you can add translatable strings to you application. For them to work you have to take a few steps.</p><p>First of all, you need to make sure that you have the TemplateTranslationTiein and <a href="introduction_Translation.html">Translation</a> components installed as well. The TranslationTemplate component provides the glue between the Template component and the Translation component.</p><p>Then you have to configure the template system with the correct configuration for translations:</p><ol class="code">
<li><span style="color: #000000">&lt;?php</span></li>
<li><span style="color: #007700">//&nbsp;Create&nbsp;a&nbsp;normal&nbsp;template&nbsp;configuration&nbsp;and&nbsp;create&nbsp;the&nbsp;translation&nbsp;configuration</span></li>
<li><span style="color: #000000">$tc&nbsp;</span><span style="color: #0000FF">=&nbsp;new&nbsp;</span><span style="color: #000000">ezcTemplateConfiguration</span><span style="color: #0000FF">;</span></li>
<li><span style="color: #000000">$tc</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">translation&nbsp;</span><span style="color: #0000FF">=&nbsp;</span><span style="color: #000000"><a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTemplateTranslationConfiguration.html#getInstance'>ezcTemplateTranslationConfiguration::getInstance</a></span><span style="color: #0000FF">();</span></li>
<li></li>
<li><span style="color: #007700">//&nbsp;Create&nbsp;a&nbsp;translation&nbsp;manager,&nbsp;and&nbsp;assign&nbsp;it&nbsp;to&nbsp;the&nbsp;template&nbsp;translation</span></li>
<li><span style="color: #007700">//&nbsp;configuration</span></li>
<li><span style="color: #000000">$backend&nbsp;</span><span style="color: #0000FF">=&nbsp;new&nbsp;</span><span style="color: #000000"><a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTranslationTsBackend.html'>ezcTranslationTsBackend</a></span><span style="color: #0000FF">(&nbsp;</span><span style="color: #000000">dirname</span><span style="color: #0000FF">(&nbsp;</span><span style="color: #000000">__FILE__&nbsp;</span><span style="color: #0000FF">).&nbsp;</span><span style="color: #335533">'/translations'&nbsp;</span><span style="color: #0000FF">);</span></li>
<li><span style="color: #000000">$backend</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">setOptions</span><span style="color: #0000FF">(&nbsp;array(&nbsp;</span><span style="color: #335533">'format'&nbsp;</span><span style="color: #0000FF">=&gt;&nbsp;</span><span style="color: #335533">'[LOCALE].xml'&nbsp;</span><span style="color: #0000FF">)&nbsp;);</span></li>
<li><span style="color: #000000">$manager&nbsp;</span><span style="color: #0000FF">=&nbsp;new&nbsp;</span><span style="color: #000000"><a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTranslationManager.html'>ezcTranslationManager</a></span><span style="color: #0000FF">(&nbsp;</span><span style="color: #000000">$backend&nbsp;</span><span style="color: #0000FF">);</span></li>
<li><span style="color: #000000">$tc</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">translation</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">manager&nbsp;</span><span style="color: #0000FF">=&nbsp;</span><span style="color: #000000">$manager</span><span style="color: #0000FF">;</span></li>
<li></li>
<li><span style="color: #007700">//&nbsp;Set&nbsp;the&nbsp;locale&nbsp;to&nbsp;use</span></li>
<li><span style="color: #000000">$tc</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">translation</span><span style="color: #0000FF">-&gt;</span><span style="color: #000000">locale&nbsp;</span><span style="color: #0000FF">=&nbsp;</span><span style="color: #000000">$locale</span><span style="color: #0000FF">;</span></li>
<span style="color: #000000">?&gt;</span>
</ol><p>More information on how to configure the <a href='/zetacomponents/documentation/trunk/Template/phpdoc/ezcTranslationManager.html'>ezcTranslationManager</a> can be found in the documentation of the <a href="introduction_Translation.html">Translation</a> component. Of course, the template configuration can also be made through <a href="#lazy-initialization">Lazy initialization</a>.</p><p>After the template system knows about the translations, it will use the Translation component's mechanism to fetch translations.</p><a name="more-information"></a><a name="id85"></a><h3>More information</h3><p>For more information, see the:</p><ul><li><p><a href="../Template/functions.html">Template functions</a></p></li><li><p><a href="../Template/EBNF.html">EBNF</a></p></li><li><p><a href="../Template/phpdoc/classtrees.html">API documentation</a></p></li></ul><!--Local Variables:
mode: rst
fill-column: 79
End:
vim: et syn=rst tw=79-->

	</div>

	<div class="footer">
	Copyright © 2010 <a href="http://apache.org">The Apache Software Foundation</a>
</div>
</div>
</body>
</html>
